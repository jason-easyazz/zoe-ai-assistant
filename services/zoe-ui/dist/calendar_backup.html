<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Zoe - Calendar</title>
    <style>
        * { 
            margin: 0; padding: 0; box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', system-ui, sans-serif;
            background: linear-gradient(135deg, #fafbfc 0%, #f1f3f6 100%);
            min-height: 100vh; color: #333;
            font-size: clamp(14px, 1.6vw, 16px);
            -webkit-touch-callout: none; /* Disable iOS callout */
            -webkit-user-select: none; /* Disable text selection */
            user-select: none;
            touch-action: manipulation; /* Optimize touch responsiveness */
        }
        
        /* Navigation */
        .nav-bar {
            position: fixed; top: 0; left: 0; right: 0; background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(20px); border-bottom: 1px solid rgba(255, 255, 255, 0.3);
            padding: 10px 15px; z-index: 100; display: flex; justify-content: space-between;
            align-items: center; height: 60px;
        }
        .nav-left { display: flex; align-items: center; gap: 15px; }
        .mini-orb { 
            width: 32px; height: 32px; border-radius: 50%; 
            background: linear-gradient(135deg, #7B61FF 0%, #5AE0E0 100%); 
            cursor: pointer; transition: all 0.3s ease; min-width: 44px; min-height: 44px;
        }
        .mini-orb:hover { transform: scale(1.1); }
        .nav-menu { display: flex; gap: 20px; }
        .nav-item { 
            color: #666; text-decoration: none; 
            font-family: var(--font-family-primary);
            font-size: 13px;
            font-weight: 400;
            line-height: 1.4;
            transition: all 0.3s ease; padding: 8px 12px; border-radius: 6px;
            min-height: 44px; display: flex; align-items: center;
        }
        .nav-item:hover, .nav-item.active { color: #7B61FF; background: rgba(123, 97, 255, 0.1); }
        .nav-right { display: flex; align-items: center; gap: 10px; }
        
        .more-nav-btn { 
            color: #666; text-decoration: none; 
            font-family: var(--font-family-primary);
            font-size: 13px;
            font-weight: 400;
            line-height: 1.4;
            transition: all 0.3s ease; padding: 8px 12px; border-radius: 6px;
            min-height: 44px; display: flex; align-items: center; cursor: pointer;
            background: none; border: none;
        }
        .more-nav-btn:hover { color: #7B61FF; background: rgba(123, 97, 255, 0.1); }
        
        .settings-btn { 
            background: rgba(255, 255, 255, 0.6); border: 1px solid rgba(255, 255, 255, 0.3); 
            border-radius: 50%; width: 32px; height: 32px; display: flex; align-items: center; 
            justify-content: center; cursor: pointer; transition: all 0.3s ease; color: #666;
            font-size: 16px; font-weight: bold;
        }
        .settings-btn:hover { background: rgba(255, 255, 255, 0.8); color: #333; }
        
        .notifications-btn { 
            background: rgba(255, 255, 255, 0.6); border: 1px solid rgba(255, 255, 255, 0.3); 
            border-radius: 50%; width: 32px; height: 32px; display: flex; align-items: center; 
            justify-content: center; cursor: pointer; transition: all 0.3s ease; color: #666;
            font-size: 16px; font-weight: bold; position: relative;
        }
        .notifications-btn:hover { background: rgba(255, 255, 255, 0.8); color: #333; }
        .notifications-btn.has-notifications::after {
            content: ''; position: absolute; top: 8px; right: 8px;
            width: 8px; height: 8px; background: #ff4757; border-radius: 50%;
        }
        
        .api-indicator { 
            font-family: var(--font-family-primary);
            font-size: 12px;
            font-weight: 500;
            line-height: 1.4;
            padding: 4px 8px; border-radius: 8px; display: flex; align-items: center; gap: 6px; 
        }
        .api-indicator.online { background: rgba(34, 197, 94, 0.1); color: #22c55e; }
        .api-indicator.offline { background: rgba(239, 68, 68, 0.1); color: #ef4444; }
        .api-indicator.warning { background: rgba(251, 146, 60, 0.1); color: #ea580c; }
        .api-indicator::before { content: ''; width: 8px; height: 8px; border-radius: 50%; display: inline-block; }
        .api-indicator.online::before { background: #22c55e; }
        .api-indicator.offline::before { background: #ef4444; }
        .api-indicator.warning::before { background: #ea580c; }

        /* Main Layout */
        .main-container { padding: 70px 20px 20px; }
        .top-info-bar { 
            display: flex; justify-content: space-between; align-items: center; 
            margin-bottom: 20px; padding: 0 10px;
        }
        .time-display { display: flex; flex-direction: column; }
        .current-time { 
            font-family: var(--font-family-display);
            font-size: 18px;
            font-weight: 300;
            line-height: 1.2;
            color: #333; 
        }
        .current-date { 
            font-family: var(--font-family-primary);
            font-size: 11px;
            font-weight: 400;
            line-height: 1.4;
            color: #666; margin-top: 2px; 
        }
        .weather-widget { display: flex; align-items: center; gap: 6px; }

        /* Calendar Header - Optimized for Pi Touch */
        .calendar-header { 
            display: flex; justify-content: space-between; align-items: center; 
            margin-bottom: 15px; padding: 0 5px;
        }
        .calendar-header-left {
            display: flex; align-items: center; gap: 10px;
        }
        .calendar-header-center {
            flex: 1; text-align: center;
        }
        .calendar-header-right {
            display: flex; align-items: center; gap: 10px;
        }
        .month-title { 
            font-family: var(--font-family-display);
            font-size: clamp(18px, 4vw, 22px);
            font-weight: 300;
            line-height: 1.2;
            color: #333;
            background: linear-gradient(135deg, #7B61FF 0%, #5AE0E0 100%); 
            background-clip: text; -webkit-background-clip: text; -webkit-text-fill-color: transparent;
        }
        .nav-button { 
            background: rgba(255, 255, 255, 0.6); border: 1px solid rgba(255, 255, 255, 0.3); 
            border-radius: 6px; width: 36px; height: 36px; display: flex; align-items: center; 
            justify-content: center; cursor: pointer; transition: all 0.3s ease; 
            color: #666; 
            font-family: var(--font-family-primary);
            font-size: var(--font-size-sm);
            font-weight: var(--font-weight-semibold);
            line-height: var(--line-height-normal);
            min-width: 44px; min-height: 44px; /* Touch target */
        }
        .view-toggle {
            display: flex; background: rgba(255, 255, 255, 0.6); 
            border: 1px solid rgba(255, 255, 255, 0.3); border-radius: 6px;
            overflow: hidden;
        }
        .view-toggle-btn {
            padding: 10px 14px; background: transparent; border: none;
            cursor: pointer; transition: all 0.3s ease; 
            font-family: var(--font-family-primary);
            font-size: var(--font-size-xs);
            font-weight: var(--font-weight-medium);
            line-height: var(--line-height-normal);
            color: #666; font-weight: 500; min-width: 44px; min-height: 44px;
            display: flex; align-items: center; justify-content: center;
        }
        .view-toggle-btn.active {
            background: linear-gradient(135deg, #7B61FF 0%, #5AE0E0 100%);
            color: white;
        }

        /* Calendar Layout */
        .calendar-layout { 
            display: grid; grid-template-columns: 2fr 1fr; gap: 20px; 
            max-width: 1200px; margin: 0 auto; align-items: start;
        }

        /* Calendar Grid */
        .calendar-grid { 
            display: grid; grid-template-columns: repeat(7, 1fr); gap: 4px; 
            background: rgba(255, 255, 255, 0.6); backdrop-filter: blur(40px); 
            border: 1px solid rgba(255, 255, 255, 0.4); border-radius: 16px; padding: 20px;
            height: fit-content;
        }
        .day-header { 
            text-align: center; padding: 12px 8px; 
            font-family: var(--font-family-primary);
            font-size: var(--font-size-xs);
            font-weight: var(--font-weight-semibold);
            line-height: var(--line-height-normal); 
            color: #666; text-transform: uppercase;
        }
        .calendar-day { 
            aspect-ratio: 1; display: flex; align-items: center; justify-content: center; 
            border-radius: 8px; 
            font-family: var(--font-family-primary);
            font-size: var(--font-size-sm);
            font-weight: var(--font-weight-normal);
            line-height: var(--line-height-normal);
            cursor: pointer; transition: all 0.3s ease; 
            position: relative; font-weight: 500; min-height: 40px;
        }
        .calendar-day:hover { background: rgba(123, 97, 255, 0.1); transform: scale(1.05); }
        .calendar-day.today { 
            background: linear-gradient(135deg, #7B61FF 0%, #5AE0E0 100%); 
            color: white; font-weight: 600;
        }
        .calendar-day.selected { 
            background: rgba(123, 97, 255, 0.3); color: #7B61FF; font-weight: 600; 
            border: 2px solid #7B61FF;
        }
        .calendar-day.has-event { background: rgba(123, 97, 255, 0.2); color: #7B61FF; }
        .calendar-day.has-event::after { 
            content: ''; position: absolute; bottom: 4px; left: 50%; transform: translateX(-50%); 
            width: 4px; height: 4px; background: #7B61FF; border-radius: 50%;
        }
        .calendar-day.other-month { color: #ccc; opacity: 0.5; }

        /* Day View Styles - Pi Touch Optimized */
        .day-view {
            display: none; margin-bottom: 15px;
        }
        .day-view.active { display: block; }
        .day-view-layout {
            display: grid; grid-template-columns: 2fr 1fr; gap: 15px;
            height: calc(100vh - 200px); max-height: 500px;
            overflow: hidden; /* Prevent whole page scrolling */
        }
        
        /* Simple day timeline */
        .day-timeline {
            display: flex;
            height: 100%;
            max-height: 500px;
            overflow-y: auto;
            overflow-x: hidden;
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: 8px;
            background: #fafafa;
        }
        
        .timeline-labels {
            width: 60px;
            flex-shrink: 0;
            background: rgba(255, 255, 255, 0.95);
            border-right: 1px solid rgba(0, 0, 0, 0.1);
        }
        
        .timeline-label {
            height: 60px;
            display: flex;
            align-items: flex-start;
            justify-content: center;
            font-size: 11px;
            color: #666;
            font-weight: 500;
            padding-top: 8px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.05);
        }
        
        .timeline-events {
            flex: 1;
            position: relative;
            min-height: 1440px; /* 24 hours * 60px per hour */
            background: #fafafa;
        }
        
        .time-line {
            position: absolute; left: 0; right: 0; height: 1px;
            background: rgba(0, 0, 0, 0.08);
            pointer-events: none;
            z-index: 1;
        }
        
        .time-line.hour {
            background: rgba(0, 0, 0, 0.15);
            height: 1px;
        }
        
        .current-time-line {
            position: absolute; left: 0; right: 0; height: 2px;
            background: linear-gradient(90deg, #7B61FF 0%, #5AE0E0 100%);
            z-index: 5;
            pointer-events: none;
            box-shadow: 0 1px 3px rgba(123, 97, 255, 0.3);
        }
        .day-view-header {
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 15px; padding: 0 5px;
        }
        .day-view-title {
            font-family: var(--font-family-display);
            font-size: clamp(16px, 3vw, 18px);
            font-weight: 300;
            line-height: 1.2;
            color: #333;
            background: linear-gradient(135deg, #7B61FF 0%, #5AE0E0 100%); 
            background-clip: text; -webkit-background-clip: text; -webkit-text-fill-color: transparent;
        }
        .day-view-nav {
            display: flex; gap: 8px;
        }
        .day-events, .day-tasks {
            background: rgba(255, 255, 255, 0.6); backdrop-filter: blur(40px);
            border: 1px solid rgba(255, 255, 255, 0.4); border-radius: 12px; 
            padding: 4px; overflow: hidden; /* Prevent scrolling at this level */
            height: 100%;
        }
        .section-title {
            font-family: var(--font-family-display);
            font-size: 14px;
            font-weight: 600;
            line-height: 1.2;
            color: #333; margin-bottom: 6px;
            text-transform: none; letter-spacing: 0px; padding-bottom: 4px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.3);
            display: flex; justify-content: space-between; align-items: center;
        }
        .task-filter-buttons {
            display: flex; gap: 4px;
        }
        .filter-btn {
            padding: 4px 8px; font-size: 10px; border: 1px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.4); border-radius: 4px; cursor: pointer;
            transition: all 0.3s ease; color: #666; font-weight: 500;
        }
        .filter-btn:hover, .filter-btn.active {
            background: linear-gradient(135deg, #7B61FF 0%, #5AE0E0 100%);
            color: white; border-color: transparent;
        }

        /* Task Styles - Pi Touch Optimized */
        .task-item {
            background: rgba(255, 255, 255, 0.6); border: 1px solid rgba(255, 255, 255, 0.3);
            border-left: 3px solid transparent; border-radius: 8px; padding: 6px; margin-bottom: 4px; cursor: grab;
            transition: all 0.3s ease; position: relative;
            min-height: 35px; display: flex; align-items: center; justify-content: space-between;
            touch-action: none; /* Prevent scrolling while dragging */
            user-select: none; /* Prevent text selection while dragging */
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }
        
        .task-item.completed {
            opacity: 0.6; text-decoration: line-through;
        }
        
        .task-checkbox {
            margin-right: 8px;
        }
        
        .task-checkbox input[type="checkbox"] {
            width: 16px; height: 16px; cursor: pointer;
            accent-color: #7B61FF;
        }
        .task-item:hover, .task-item:active {
            background: rgba(255, 255, 255, 0.8); transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .task-item.dragging {
            opacity: 0.6; transform: rotate(3deg) scale(1.05);
            box-shadow: 0 4px 16px rgba(123, 97, 255, 0.3);
            z-index: 1000;
        }
        .task-text {
            font-family: var(--font-family-primary);
            font-size: 12px;
            font-weight: 400;
            line-height: 1.2;
            color: #333; margin: 0; flex: 1;
            overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
        }
        .task-meta {
            display: flex; justify-content: space-between; align-items: center;
            font-family: var(--font-family-primary);
            font-size: 9px;
            font-weight: 400;
            line-height: 1.2;
            color: #666;
        }
        .task-priority {
            padding: 2px 4px; border-radius: 3px; 
            font-family: var(--font-family-primary);
            font-size: 8px;
            font-weight: 500;
            line-height: 1.2;
        }
        .task-category {
            padding: 3px 6px; border-radius: 4px; 
            font-family: var(--font-family-primary);
            font-size: 9px;
            font-weight: 500;
            line-height: 1.4;
            text-transform: capitalize;
        }
        .priority-high { background: rgba(239, 68, 68, 0.2); color: #dc2626; }
        .priority-medium { background: rgba(251, 146, 60, 0.2); color: #ea580c; }
        .priority-low { background: rgba(34, 197, 94, 0.2); color: #16a34a; }

        /* Drop Zones - Pi Touch Optimized */
        .time-slot {
            border: none; border-radius: 6px;
            padding: 1px; margin-bottom: 1px; min-height: 24px;
            transition: all 0.3s ease; position: relative;
            background: transparent;
            cursor: pointer; /* Make entire slot clickable */
        }
        .time-slot.drag-over {
            background: rgba(123, 97, 255, 0.1);
            transform: scale(1.01);
        }
        .time-slot-content {
            min-height: 22px; display: flex; align-items: center; flex-wrap: wrap; gap: 1px;
            transition: all 0.2s ease; position: relative;
        }
        .time-slot-content:empty::after {
            content: 'Drop task here'; color: rgba(255, 255, 255, 0.5);
            font-size: 11px; font-style: italic;
        }
        .time-slot-label {
            font-size: 10px; font-weight: 600; color: #7B61FF; margin-bottom: 4px;
        }
        /* Improved drop zone detection */
        .time-slot:hover {
            border-color: rgba(123, 97, 255, 0.5);
            background: rgba(123, 97, 255, 0.05);
        }
        .scheduled-task {
            background: rgba(255, 255, 255, 0.9); border: 1px solid rgba(0, 0, 0, 0.1);
            border-left: 4px solid transparent; border-radius: 6px; padding: 6px 10px; margin: 0; font-size: 13px;
            position: absolute; cursor: default; transition: all 0.3s ease;
            min-height: 34px; display: flex; align-items: center; justify-content: space-between;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            z-index: 2;
            touch-action: none; /* Prevent touch scrolling when dragging */
            width: 100%; /* Default to full width */
        }
        .scheduled-task:hover {
            background: rgba(255, 255, 255, 1); transform: translateY(-1px);
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.2);
        }
        .scheduled-task.dragging {
            opacity: 0.7;
            transform: rotate(2deg);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        /* Drag target visual feedback */
        .timeline-events.drag-over {
            background: rgba(123, 97, 255, 0.1);
            border: 2px dashed rgba(123, 97, 255, 0.5);
        }
        
        .drop-zone-indicator {
            position: absolute;
            left: 0;
            right: 0;
            height: 60px;
            background: rgba(123, 97, 255, 0.2);
            border: 2px dashed rgba(123, 97, 255, 0.8);
            border-radius: 4px;
            pointer-events: none;
            z-index: 10;
            transition: all 0.2s ease;
        }
        .scheduled-task .task-text {
            font-size: 13px; margin: 0; flex: 1; color: #333; font-weight: 500;
            overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
            line-height: 1.2;
        }
        .scheduled-task .task-meta {
            display: flex; justify-content: space-between; align-items: center;
            font-size: 10px;
        }
        .scheduled-task button {
            background: rgba(239, 68, 68, 0.2); border: none; border-radius: 4px;
            color: #dc2626; cursor: pointer; padding: 2px 6px; font-size: 10px;
        }
        .scheduled-task button:hover {
            background: rgba(239, 68, 68, 0.3);
        }
        
        
        /* Event duration indicator removed - events are now resizable */

        /* All Day Events */
        .all-day-events {
            margin-bottom: 4px;
        }
        .all-day-event {
            background: rgba(255, 255, 255, 0.3); border: 1px solid rgba(255, 255, 255, 0.2);
            border-left: 3px solid transparent; border-radius: 8px; padding: 6px; margin-bottom: 3px; font-size: 11px;
            display: flex; justify-content: space-between; align-items: center;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }
        .all-day-event .task-text {
            font-size: 12px; margin: 0; flex: 1;
        }
        .all-day-event .task-meta {
            display: flex; align-items: center; gap: 8px; font-size: 10px;
        }
        .all-day-event button {
            background: rgba(239, 68, 68, 0.2); border: none; border-radius: 4px;
            color: #dc2626; cursor: pointer; padding: 2px 6px; font-size: 10px;
        }

        /* Right Panel */
        .right-panel { 
            background: rgba(255, 255, 255, 0.6); backdrop-filter: blur(40px); 
            border: 1px solid rgba(255, 255, 255, 0.4); border-radius: 16px; 
            padding: 20px; display: flex; flex-direction: column; 
            height: 100%; position: relative; align-self: stretch;
        }
        
        .panel-header { 
            margin-bottom: 20px; text-align: center; 
            padding-bottom: 15px; border-bottom: 1px solid rgba(255, 255, 255, 0.3);
            flex-shrink: 0;
        }
        .selected-date { 
            font-size: clamp(18px, 2.5vw, 20px); font-weight: 300; color: #333; margin-bottom: 2px;
            background: linear-gradient(135deg, #7B61FF 0%, #5AE0E0 100%); 
            background-clip: text; -webkit-background-clip: text; -webkit-text-fill-color: transparent;
        }
        .selected-weekday { 
            font-size: clamp(11px, 1.4vw, 12px); color: #666; font-weight: 400; 
            text-transform: uppercase; letter-spacing: 0.5px;
        }

        .panel-content { 
            flex: 1; overflow-y: auto; padding-bottom: 0;
            min-height: 300px; max-height: calc(100% - 40px);
        }
        .events-list { margin-bottom: 0; }
        
        /* Reminders Section */
        .reminders-section {
            margin-top: 0; padding-top: 0; border-top: 1px solid rgba(255, 255, 255, 0.3);
        }
        .section-header {
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 15px;
        }
        .section-title {
            font-family: var(--font-family-display);
            font-size: 16px; 
            font-weight: 600; 
            line-height: 1.4;
            color: #333; 
            margin: 0;
        }
        .add-reminder-btn {
            width: 32px; height: 32px; border-radius: 50%; border: none;
            background: linear-gradient(135deg, #7B61FF 0%, #5AE0E0 100%);
            color: white; font-size: 18px; font-weight: 600;
            cursor: pointer; transition: all 0.3s ease; min-width: 44px; min-height: 44px;
        }
        .add-reminder-btn:hover { transform: scale(1.1); }
        .reminders-list {
            display: flex; flex-direction: column; gap: 4px;
        }
        .reminder-item {
            background: rgba(255, 255, 255, 0.3); border-left: 3px solid transparent;
            border-radius: 8px; padding: 6px; margin-bottom: 4px; transition: all 0.3s ease; cursor: pointer;
            min-height: 35px; display: flex; flex-direction: column;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }
        .reminder-item:hover { transform: translateX(4px); background: rgba(255, 255, 255, 0.5); }
        .reminder-title {
            font-size: 11px; font-weight: 500; color: #333;
            overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
            line-height: 1.1;
        }
        .reminder-meta {
            font-size: 9px; color: #666; display: flex; gap: 6px; align-items: center;
        }
        .reminder-time {
            color: #7B61FF; font-weight: 500;
        }
        .reminder-priority {
            padding: 2px 8px; border-radius: 12px; font-size: 10px; font-weight: 600;
        }
        .priority-critical { background: #ff4757; color: white; }
        .priority-high { background: #ff6b7a; color: white; }
        .priority-medium { background: #ffa502; color: white; }
        .priority-low { background: #70a1ff; color: white; }
        
        /* Priority dots for compact display */
        .priority-dot {
            width: 8px; height: 8px; border-radius: 50%; display: inline-block;
            margin-left: 6px; flex-shrink: 0;
        }
        .priority-dot.critical { background: #ff4757; }
        .priority-dot.high { background: #ff6b7a; }
        .priority-dot.medium { background: #ffa502; }
        .priority-dot.low { background: #70a1ff; }
        
        /* Beautiful Pastel Colors for All Tiles */
        .event-item.category-personal, .scheduled-task.category-personal, .task-item.category-personal, .reminder-item.category-personal, .all-day-event.category-personal { 
            background: rgba(147, 51, 234, 0.15); 
            border-left: 3px solid rgba(147, 51, 234, 0.3);
            color: #7c3aed;
        }
        .event-item.category-work, .scheduled-task.category-work, .task-item.category-work, .reminder-item.category-work, .all-day-event.category-work { 
            background: rgba(59, 130, 246, 0.15); 
            border-left: 3px solid rgba(59, 130, 246, 0.3);
            color: #2563eb;
        }
        .event-item.category-health, .scheduled-task.category-health, .reminder-item.category-health, .all-day-event.category-health { 
            background: rgba(239, 68, 68, 0.15); 
            border-left: 3px solid rgba(239, 68, 68, 0.3);
            color: #dc2626;
        }
        .event-item.category-social, .scheduled-task.category-social, .reminder-item.category-social, .all-day-event.category-social { 
            background: rgba(251, 146, 60, 0.15); 
            border-left: 3px solid rgba(251, 146, 60, 0.3);
            color: #ea580c;
        }
        .event-item.category-family, .scheduled-task.category-family, .reminder-item.category-family, .all-day-event.category-family { 
            background: rgba(236, 72, 153, 0.15); 
            border-left: 3px solid rgba(236, 72, 153, 0.3);
            color: #db2777;
        }
        .event-item.category-task, .scheduled-task.category-task, .task-item.category-task, .reminder-item.category-task, .all-day-event.category-task { 
            background: rgba(34, 197, 94, 0.15); 
            border-left: 3px solid rgba(34, 197, 94, 0.3);
            color: #16a34a;
        }
        .reminder-item.category-urgent { 
            background: rgba(239, 68, 68, 0.2); 
            border-left: 3px solid rgba(239, 68, 68, 0.4);
            color: #dc2626;
        }
        .category-urgent { background: rgba(255, 71, 87, 0.2); color: #ff4757; border-left: 3px solid #ff4757; }
        .no-reminders {
            text-align: center; color: #666; font-size: 14px; padding: 20px;
        }
        
        /* Loading Overlay */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }
        
        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(123, 97, 255, 0.3);
            border-top: 4px solid #7B61FF;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        .loading-text {
            color: white;
            margin-top: 15px;
            font-size: 16px;
            font-weight: 500;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Event Reminders */
        .add-reminder-to-event-btn {
            background: linear-gradient(135deg, #7B61FF 0%, #5AE0E0 100%);
            color: white; border: none; border-radius: 8px; padding: 10px 16px;
            font-size: 14px; font-weight: 500; cursor: pointer; transition: all 0.3s ease;
            margin-top: 10px;
        }
        .add-reminder-to-event-btn:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(123, 97, 255, 0.3); }
        
        .event-reminder-item {
            background: rgba(255, 255, 255, 0.6); backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.4); border-radius: 8px;
            padding: 10px; margin-bottom: 8px; display: flex; justify-content: space-between;
            align-items: center;
        }
        .event-reminder-details {
            flex: 1;
        }
        .event-reminder-time {
            font-size: 12px; color: #7B61FF; font-weight: 500;
        }
        .event-reminder-priority {
            padding: 2px 6px; border-radius: 8px; font-size: 10px; font-weight: 600;
            margin-left: 8px;
        }
        .remove-reminder-btn {
            background: #ff4757; color: white; border: none; border-radius: 4px;
            width: 24px; height: 24px; font-size: 12px; cursor: pointer;
            display: flex; align-items: center; justify-content: center;
        }
        
        /* Link Item Modal */
        .link-item-modal {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.5); backdrop-filter: blur(10px);
            display: flex; align-items: center; justify-content: center;
            z-index: 2000; opacity: 0; visibility: hidden; transition: all 0.3s ease;
        }
        .link-item-modal.active { opacity: 1; visibility: visible; }
        .link-item-content {
            background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.5); border-radius: 16px;
            padding: 20px; max-width: 500px; width: 90%; position: relative;
            transform: scale(0.9); transition: transform 0.3s ease;
        }
        .link-item-modal.active .link-item-content { transform: scale(1); }
        .link-item-header {
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 20px; padding-bottom: 10px; border-bottom: 1px solid rgba(255, 255, 255, 0.3);
        }
        .link-item-title {
            font-size: 18px; font-weight: 600; color: #333; margin: 0;
        }
        .link-item-close {
            background: rgba(255, 255, 255, 0.8); border: none; border-radius: 50%;
            width: 32px; height: 32px; font-size: 16px; cursor: pointer; color: #666;
            display: flex; align-items: center; justify-content: center;
        }
        .link-item-field {
            margin-bottom: 15px;
        }
        .link-item-label {
            display: block; font-size: 14px; font-weight: 500; color: #333;
            margin-bottom: 5px;
        }
        .link-item-input {
            width: 100%; padding: 10px; border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px; background: rgba(255, 255, 255, 0.6);
            font-size: 14px; color: #333; transition: all 0.3s ease;
        }
        .link-item-input:focus {
            outline: none; border-color: #7B61FF; background: rgba(255, 255, 255, 0.8);
        }
        .link-item-actions {
            display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px;
        }
        .link-item-cancel, .link-item-save {
            padding: 10px 20px; border: none; border-radius: 8px; font-size: 14px;
            font-weight: 500; cursor: pointer; transition: all 0.3s ease;
        }
        .link-item-cancel {
            background: rgba(255, 255, 255, 0.6); color: #666; border: 1px solid rgba(255, 255, 255, 0.3);
        }
        .link-item-cancel:hover { background: rgba(255, 255, 255, 0.8); }
        .link-item-save {
            background: linear-gradient(135deg, #7B61FF 0%, #5AE0E0 100%); color: white;
        }
        .link-item-save:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(123, 97, 255, 0.3); }
        
        /* Event Links */
        .links-list {
            display: flex; flex-direction: column; gap: 8px; margin-top: 10px;
        }
        .event-link-item {
            background: rgba(255, 255, 255, 0.6); backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.4); border-radius: 8px;
            padding: 10px; display: flex; justify-content: space-between; align-items: center;
        }
        .event-link-details {
            flex: 1;
        }
        .event-link-text {
            font-size: 14px; font-weight: 500; color: #333; margin-bottom: 2px;
        }
        .event-link-meta {
            font-size: 12px; color: #666; display: flex; gap: 8px;
        }
        .event-link-list {
            color: #7B61FF; font-weight: 500;
        }
        .event-link-when {
            color: #ffa502; font-weight: 500;
        }
        .add-link-to-event-btn {
            background: linear-gradient(135deg, #7B61FF 0%, #5AE0E0 100%);
            color: white; border: none; border-radius: 8px; padding: 10px 16px;
            font-size: 14px; font-weight: 500; cursor: pointer; transition: all 0.3s ease;
            margin-top: 10px;
        }
        .add-link-to-event-btn:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(123, 97, 255, 0.3); }
        .no-links {
            text-align: center; color: #666; font-size: 14px; padding: 20px;
        }
        
        /* Notifications Panel */
        .notifications-panel {
            position: fixed; top: 0; right: -400px; width: 400px; height: 100vh;
            background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(20px);
            border-left: 1px solid rgba(255, 255, 255, 0.3); z-index: 1000;
            transition: right 0.3s ease; overflow-y: auto;
        }
        .notifications-panel.open { right: 0; }
        .notifications-header {
            padding: 20px; border-bottom: 1px solid rgba(255, 255, 255, 0.3);
            display: flex; justify-content: space-between; align-items: center;
        }
        .notifications-title {
            font-size: 18px; font-weight: 600; color: #333; margin: 0;
        }
        .notifications-close {
            width: 32px; height: 32px; border-radius: 50%; border: none;
            background: rgba(255, 255, 255, 0.3); color: #666; font-size: 18px;
            cursor: pointer; transition: all 0.3s ease; min-width: 44px; min-height: 44px;
        }
        .notifications-close:hover { background: rgba(255, 255, 255, 0.5); }
        .notifications-content {
            padding: 20px; display: flex; flex-direction: column; gap: 15px;
        }
        .notification-item {
            background: rgba(255, 255, 255, 0.6); backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.4); border-radius: 12px;
            padding: 15px; transition: all 0.3s ease; cursor: pointer;
        }
        .notification-item:hover { transform: translateY(-2px); box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1); }
        .notification-item.unread { border-left: 4px solid #7B61FF; }
        .notification-title {
            font-size: 14px; font-weight: 600; color: #333; margin-bottom: 5px;
        }
        .notification-meta {
            font-size: 12px; color: #666; display: flex; gap: 10px;
        }
        .notification-time {
            color: #7B61FF; font-weight: 500;
        }
        .notification-priority {
            padding: 2px 8px; border-radius: 12px; font-size: 10px; font-weight: 600;
        }
        .no-notifications {
            text-align: center; color: #666; font-size: 14px; padding: 40px 20px;
        }
        
        .event-item { 
            padding: 8px; border-left: 3px solid transparent;
            cursor: pointer; transition: all 0.3s ease; border-radius: 8px; margin-bottom: 4px;
            background: rgba(255, 255, 255, 0.3); position: relative;
            min-height: 45px; display: flex; flex-direction: column;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }
        .event-item:hover { 
            transform: translateX(4px); background: rgba(255, 255, 255, 0.5); 
        }
        .event-time { 
            font-size: 10px; color: #7B61FF; font-weight: 600; margin-bottom: 2px; 
            text-transform: uppercase;
        }
        .event-title { 
            font-size: 12px; color: #333; font-weight: 500; margin-bottom: 0;
            overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
            line-height: 1.2;
        }
        .event-category { 
            display: inline-block; padding: 4px 8px; border-radius: 10px; 
            font-size: 10px; font-weight: 500; margin-top: 4px;
        }
        /* Category colors now handled by tile background colors above */

        .event-actions {
            position: absolute; top: 12px; right: 12px; display: flex; gap: 8px;
            opacity: 1;
        }
        .action-btn {
            background: rgba(255, 255, 255, 0.9); border: none; border-radius: 8px; 
            width: 36px; height: 36px; font-size: 14px; cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            transition: all 0.3s ease; box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .edit-btn { color: #7B61FF; }
        .edit-btn:hover { background: rgba(123, 97, 255, 0.2); transform: scale(1.1); }
        .delete-btn { color: #dc2626; }
        .delete-btn:hover { background: rgba(239, 68, 68, 0.2); transform: scale(1.1); }

        .events-summary {
            padding: 12px; margin-bottom: 12px; background: rgba(255, 255, 255, 0.4);
            border-radius: 10px; font-size: 12px; color: #666;
        }

        .no-events { text-align: center; color: #666; font-style: italic; padding: 40px; }

        .panel-footer {
            position: absolute; bottom: 0; left: 0; right: 0;
            background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(20px);
            border-top: 1px solid rgba(255, 255, 255, 0.3);
            padding: 4px 20px; border-radius: 0 0 16px 16px;
            flex-shrink: 0;
        }
        .day-summary { 
            display: flex; justify-content: space-around;
        }
        .summary-stat { text-align: center; }
        .stat-number-small { 
            display: block; font-size: clamp(18px, 2.5vw, 20px); font-weight: 600; 
            color: #7B61FF; margin-bottom: 4px;
        }
        .stat-label-small { 
            font-size: clamp(10px, 1.3vw, 11px); color: #666; text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .floating-add-btn { 
            position: fixed; bottom: 30px; right: 30px; width: 64px; height: 64px; 
            border-radius: 50%; background: linear-gradient(135deg, #7B61FF 0%, #5AE0E0 100%); 
            border: none; color: white; cursor: pointer; display: flex; align-items: center; 
            justify-content: center; font-size: 28px; transition: all 0.3s ease; 
            z-index: 1000; box-shadow: 0 4px 12px rgba(123, 97, 255, 0.3);
        }
        .floating-add-btn:hover { transform: scale(1.1); box-shadow: 0 6px 16px rgba(123, 97, 255, 0.4); }

        /* More Overlay */
        .more-overlay {
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background: rgba(0, 0, 0, 0.4); backdrop-filter: blur(8px);
            display: none; align-items: center; justify-content: center; z-index: 3000;
            opacity: 0; transition: all 0.3s ease;
        }
        .more-overlay.active { display: flex; opacity: 1; }
        .more-content {
            background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(60px);
            border: 1px solid rgba(255, 255, 255, 0.5); border-radius: 20px;
            padding: 40px; max-width: 500px; width: 90%; position: relative;
            transform: scale(0.8); transition: transform 0.3s ease;
        }
        .more-overlay.active .more-content { transform: scale(1); }
        .more-header { text-align: center; margin-bottom: 30px; }
        .more-title {
            font-size: 24px; font-weight: 300; color: #333; margin-bottom: 10px;
            background: linear-gradient(135deg, #7B61FF 0%, #5AE0E0 100%);
            background-clip: text; -webkit-background-clip: text; -webkit-text-fill-color: transparent;
        }
        .more-close {
            position: absolute; top: 15px; right: 15px; 
            background: rgba(255, 255, 255, 0.6); border: none;
            border-radius: 50%; width: 36px; height: 36px;
            font-size: 18px; cursor: pointer; color: #666;
        }
        .more-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; }
        .more-item {
            background: rgba(255, 255, 255, 0.8); border: 1px solid rgba(255, 255, 255, 0.4);
            border-radius: 16px; padding: 24px; text-align: center; cursor: pointer;
            transition: all 0.3s ease; min-height: 120px; display: flex;
            flex-direction: column; align-items: center; justify-content: center;
        }
        .more-item:hover {
            background: linear-gradient(135deg, #7B61FF 0%, #5AE0E0 100%);
            color: white; transform: translateY(-4px);
        }
        .more-item-icon { font-size: 36px; margin-bottom: 12px; }
        .more-item-label { font-size: 15px; font-weight: 500; }

        /* Item Details Overlay */
        .item-details-overlay {
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background: rgba(0, 0, 0, 0.4); backdrop-filter: blur(8px);
            display: none; align-items: center; justify-content: center; z-index: 4000;
            opacity: 0; transition: all 0.3s ease;
        }
        .item-details-overlay.active { display: flex; opacity: 1; }
        .item-details-content {
            background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(60px);
            border: 1px solid rgba(255, 255, 255, 0.5); border-radius: 20px;
            padding: 30px; max-width: 600px; width: 90%; position: relative;
            transform: scale(0.8); transition: transform 0.3s ease;
            max-height: 80vh; overflow-y: auto;
        }
        .item-details-overlay.active .item-details-content { transform: scale(1); }
        .item-details-header { 
            display: flex; justify-content: space-between; align-items: center; 
            margin-bottom: 20px; padding-bottom: 15px; 
            border-bottom: 1px solid rgba(255, 255, 255, 0.3);
        }
        .item-details-title {
            font-size: 20px; font-weight: 300; color: #333;
            background: linear-gradient(135deg, #7B61FF 0%, #5AE0E0 100%);
            background-clip: text; -webkit-background-clip: text; -webkit-text-fill-color: transparent;
        }
        .item-details-close {
            background: rgba(255, 255, 255, 0.6); border: none;
            border-radius: 50%; width: 36px; height: 36px;
            font-size: 18px; cursor: pointer; color: #666;
        }
        .item-details-body { margin-bottom: 20px; }
        .item-details-field {
            margin-bottom: 15px; display: flex; flex-direction: column;
        }
        .item-details-label {
            font-size: 12px; color: #666; margin-bottom: 5px; font-weight: 600;
            text-transform: uppercase; letter-spacing: 0.5px;
        }
        .item-details-value {
            font-size: 14px; color: #333; padding: 8px 12px;
            background: rgba(255, 255, 255, 0.6); border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        .item-details-actions {
            display: flex; gap: 10px; justify-content: flex-end;
            padding-top: 15px; border-top: 1px solid rgba(255, 255, 255, 0.3);
        }
        .item-details-btn {
            padding: 10px 20px; border: none; border-radius: 8px;
            cursor: pointer; font-size: 14px; font-weight: 500;
            transition: all 0.3s ease; min-width: 80px;
        }
        .item-details-btn.edit {
            background: linear-gradient(135deg, #7B61FF 0%, #5AE0E0 100%);
            color: white;
        }
        .item-details-btn.delete {
            background: rgba(239, 68, 68, 0.2); color: #dc2626;
            border: 1px solid rgba(239, 68, 68, 0.3);
        }
        .item-details-btn:hover {
            transform: translateY(-1px); box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        /* Add Event Options Overlay */
        .add-options-overlay {
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background: rgba(0, 0, 0, 0.4); backdrop-filter: blur(8px);
            display: none; align-items: center; justify-content: center; z-index: 5000;
            opacity: 0; transition: all 0.3s ease;
        }
        .add-options-overlay.active { display: flex; opacity: 1; }
        .add-options-content {
            background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(60px);
            border: 1px solid rgba(255, 255, 255, 0.5); border-radius: 20px;
            padding: 30px; max-width: 400px; width: 90%; position: relative;
            transform: scale(0.8); transition: transform 0.3s ease;
        }
        .add-options-overlay.active .add-options-content { transform: scale(1); }
        .add-options-header { text-align: center; margin-bottom: 25px; }
        .add-options-title {
            font-size: 20px; font-weight: 300; color: #333; margin-bottom: 10px;
            background: linear-gradient(135deg, #7B61FF 0%, #5AE0E0 100%);
            background-clip: text; -webkit-background-clip: text; -webkit-text-fill-color: transparent;
        }
        .add-options-close {
            position: absolute; top: 15px; right: 15px; 
            background: rgba(255, 255, 255, 0.6); border: none;
            border-radius: 50%; width: 36px; height: 36px;
            font-size: 18px; cursor: pointer; color: #666;
        }
        .add-options-grid { display: grid; grid-template-columns: 1fr; gap: 15px; }
        .add-option-item {
            background: rgba(255, 255, 255, 0.8); border: 1px solid rgba(255, 255, 255, 0.4);
            border-radius: 16px; padding: 20px; text-align: center; cursor: pointer;
            transition: all 0.3s ease; display: flex; align-items: center; gap: 15px;
        }
        .add-option-item:hover {
            background: linear-gradient(135deg, #7B61FF 0%, #5AE0E0 100%);
            color: white; transform: translateY(-2px);
        }
        .add-option-icon { font-size: 24px; }
        .add-option-text { font-size: 16px; font-weight: 500; }

        /* Enhanced Add Event Form */
        .enhanced-add-overlay {
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background: rgba(0, 0, 0, 0.4); backdrop-filter: blur(8px);
            display: none; align-items: center; justify-content: center; z-index: 6000;
            opacity: 0; transition: all 0.3s ease;
        }
        .enhanced-add-overlay.active { display: flex; opacity: 1; }
        .enhanced-add-content {
            background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(60px);
            border: 1px solid rgba(255, 255, 255, 0.5); border-radius: 16px;
            padding: 20px; max-width: 800px; width: 98%; position: relative;
            transform: scale(0.9); transition: transform 0.3s ease;
            max-height: 85vh; overflow-y: auto;
        }
        .enhanced-add-overlay.active .enhanced-add-content { transform: scale(1); }
        .enhanced-add-header { 
            display: flex; justify-content: flex-end; align-items: center; 
            margin-bottom: 10px; padding-bottom: 5px; 
        }
        .enhanced-add-title {
            display: none; /* Hide title for 7" screen */
        }
        .enhanced-add-close {
            background: rgba(255, 255, 255, 0.8); border: none;
            border-radius: 50%; width: 32px; height: 32px;
            font-size: 16px; cursor: pointer; color: #666;
            position: absolute; top: 10px; right: 10px; z-index: 10;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        
        /* Add Type Toggle */
        .add-type-toggle {
            display: flex; gap: 10px; margin-bottom: 25px;
            background: rgba(255, 255, 255, 0.3); border-radius: 12px;
            padding: 4px; border: 1px solid rgba(255, 255, 255, 0.2);
        }
        .toggle-btn {
            flex: 1; padding: 12px 20px; border: none; border-radius: 8px;
            background: transparent; color: #666; font-size: 14px; font-weight: 500;
            cursor: pointer; transition: all 0.3s ease; min-height: 44px;
            display: flex; align-items: center; justify-content: center; gap: 8px;
        }
        .toggle-btn.active {
            background: linear-gradient(135deg, #7B61FF 0%, #5AE0E0 100%);
            color: white; box-shadow: 0 4px 12px rgba(123, 97, 255, 0.3);
        }
        .toggle-btn:hover:not(.active) {
            background: rgba(255, 255, 255, 0.5); color: #333;
        }
        .enhanced-add-layout {
            display: grid; grid-template-columns: 1fr 1fr; gap: 20px;
            align-items: start;
        }
        .enhanced-form-section {
            background: rgba(255, 255, 255, 0.6); border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 12px; padding: 15px;
        }
        .enhanced-form-title {
            font-family: var(--font-family-display);
            font-size: 16px;
            font-weight: 600;
            line-height: 1.4;
            color: #333; margin-bottom: 15px;
            display: flex; align-items: center; gap: 6px;
        }
        .enhanced-form-field {
            margin-bottom: 15px;
        }
        .enhanced-form-label {
            display: block; 
            font-family: var(--font-family-primary);
            font-size: 12px;
            font-weight: 600;
            line-height: 1.4;
            color: #666; margin-bottom: 5px;
            text-transform: uppercase; letter-spacing: 0.5px;
        }
        .enhanced-form-input {
            width: 100%; padding: 12px; border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px; background: rgba(255, 255, 255, 0.8);
            font-family: var(--font-family-primary);
            font-size: 14px;
            font-weight: 400;
            line-height: 1.4;
            color: #333; transition: all 0.3s ease;
        }
        .enhanced-form-input:focus {
            outline: none; border-color: #7B61FF; background: rgba(255, 255, 255, 0.9);
            box-shadow: 0 0 0 3px rgba(123, 97, 255, 0.1);
        }
        .enhanced-form-row {
            display: grid; grid-template-columns: 1fr 1fr; gap: 15px;
        }
        .enhanced-form-checkbox {
            display: flex; align-items: center; gap: 8px; margin-bottom: 15px;
        }
        .enhanced-form-checkbox input {
            width: 16px; height: 16px; accent-color: #7B61FF;
        }
        .enhanced-form-checkbox label {
            font-size: 14px; color: #333; cursor: pointer;
        }
        .ai-chat-section {
            text-align: center; display: flex; flex-direction: column;
            justify-content: center; align-items: center;
        }
        .ai-chat-orb {
            width: 80px; height: 80px; border-radius: 50%;
            background: linear-gradient(135deg, #7B61FF 0%, #5AE0E0 100%);
            display: flex; align-items: center; justify-content: center;
            font-size: 32px; cursor: pointer; margin-bottom: 20px;
            transition: all 0.3s ease; box-shadow: 0 4px 12px rgba(123, 97, 255, 0.3);
            animation: pulse 2s infinite;
        }
        .ai-chat-orb:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 16px rgba(123, 97, 255, 0.4);
            animation: none;
        }
        .ai-chat-text {
            font-size: 16px; font-weight: 500; color: #333;
            margin-bottom: 15px;
        }
        .voice-conversation {
            margin-top: 20px; padding: 15px; background: rgba(123, 97, 255, 0.05);
            border-radius: 8px; border: 1px solid rgba(123, 97, 255, 0.1);
        }
        .conversation-item {
            margin-bottom: 10px; padding: 8px 12px; border-radius: 6px;
            font-size: 14px; line-height: 1.4;
        }
        .conversation-item.user {
            background: rgba(123, 97, 255, 0.1); border-left: 3px solid #7B61FF;
        }
        .conversation-item.assistant {
            background: rgba(90, 224, 224, 0.1); border-left: 3px solid #5AE0E0;
        }
        .conversation-item strong {
            color: #333; margin-right: 8px;
        }
        .voice-examples {
            background: rgba(123, 97, 255, 0.1);
            border-radius: 8px; padding: 15px; text-align: left; margin-top: 15px;
        }
        .voice-examples p {
            margin: 5px 0; font-size: 12px; color: #666;
        }
        .voice-examples strong {
            color: #7B61FF;
        }
        .voice-status {
            margin: 20px 0; padding: 20px;
            background: rgba(123, 97, 255, 0.1);
            border-radius: 12px; border: 2px solid rgba(123, 97, 255, 0.2);
        }
        .voice-status.listening {
            background: rgba(255, 107, 107, 0.1);
            border-color: rgba(255, 107, 107, 0.3);
        }
        .voice-status.processing {
            background: rgba(255, 193, 7, 0.1);
            border-color: rgba(255, 193, 7, 0.3);
        }
        .voice-status.success {
            background: rgba(40, 167, 69, 0.1);
            border-color: rgba(40, 167, 69, 0.3);
        }
        .voice-icon {
            font-size: 48px; margin-bottom: 10px;
        }
        .voice-text {
            font-size: 16px; color: #333; margin-bottom: 10px;
            min-height: 20px;
        }
        .voice-transcript {
            font-size: 14px; color: #666; font-style: italic;
            min-height: 20px; max-height: 100px; overflow-y: auto;
        }
        .voice-controls {
            display: flex; gap: 12px; justify-content: center; margin-top: 20px;
        }
        .voice-btn {
            padding: 12px 24px; border: none; border-radius: 8px;
            font-size: 14px; font-weight: 500; cursor: pointer;
            transition: all 0.3s ease;
        }
        .voice-btn.primary {
            background: #7B61FF; color: white;
        }
        .voice-btn.primary:hover {
            background: #6B4CE6;
        }
        .voice-btn.secondary {
            background: #f8f9fa; color: #666; border: 1px solid #dee2e6;
        }
        .voice-btn.secondary:hover {
            background: #e9ecef;
        }
        .enhanced-form-actions {
            display: flex; gap: 15px; justify-content: flex-end; margin-top: 25px;
            padding-top: 20px; border-top: 1px solid rgba(255, 255, 255, 0.3);
        }
        .enhanced-form-btn {
            padding: 12px 24px; border: none; border-radius: 8px;
            cursor: pointer; font-size: 14px; font-weight: 500;
            transition: all 0.3s ease; min-width: 100px;
        }
        .enhanced-form-btn.primary {
            background: linear-gradient(135deg, #7B61FF 0%, #5AE0E0 100%);
            color: white;
        }
        .enhanced-form-btn.secondary {
            background: rgba(255, 255, 255, 0.6); color: #666;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        .enhanced-form-btn:hover {
            transform: translateY(-1px); box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        @media (max-width: 768px) {
            .enhanced-add-layout { grid-template-columns: 1fr; gap: 20px; }
            .enhanced-add-content { padding: 20px; max-width: 95%; }
            .enhanced-form-row { grid-template-columns: 1fr; }
        }

        /* Pi Touch Screen Optimizations */
        @media (max-width: 900px) {
            .calendar-layout { grid-template-columns: 1fr; }
            .nav-menu { display: none; }
            .day-view-layout { grid-template-columns: 1fr; height: auto; }
            .day-events, .day-tasks { min-height: 300px; }
        }
        
        /* Pi 7" Display Optimizations */
        @media (max-width: 1024px) and (min-width: 769px) {
            .main-container { padding: 70px 15px 40px; }
            .calendar-header { padding: 0 5px; margin-bottom: 15px; }
            .calendar-header-left, .calendar-header-right { gap: 10px; }
            .nav-button { width: 36px; height: 36px; font-size: 14px; }
            .view-toggle-btn { padding: 10px 15px; font-size: 13px; }
            .day-view-layout { gap: 15px; }
            .day-events, .day-tasks { padding: 4px; }
            .task-item { padding: 10px; min-height: 50px; }
            .time-slot { padding: 8px; min-height: 50px; margin-bottom: 6px; }
            .floating-add-btn { bottom: 20px; right: 20px; width: 56px; height: 56px; font-size: 24px; }
        }
        
        /* Touch-friendly interactions */
        @media (hover: none) and (pointer: coarse) {
            .nav-button, .view-toggle-btn, .floating-add-btn, .task-item, .time-slot {
                min-height: 44px;
                min-width: 44px;
                display: flex;
                align-items: center;
                justify-content: center;
            }
            
            .task-item, .time-slot {
                cursor: pointer;
                transition: all 0.2s ease;
            }
            
            .task-item:active, .time-slot:active {
                transform: scale(0.98);
                background: rgba(123, 97, 255, 0.1);
            }
        }
        
        @media (max-width: 768px) {
            .main-container { padding: 65px 8px 15px; }
            .calendar-header { padding: 0 3px; margin-bottom: 12px; }
            .calendar-header-left, .calendar-header-right { gap: 8px; }
            .nav-button { width: 32px; height: 32px; font-size: 12px; }
            .view-toggle-btn { padding: 8px 12px; font-size: 11px; }
            .day-view-layout { gap: 12px; }
            .day-events, .day-tasks { padding: 3px; }
            .task-item { padding: 8px; min-height: 45px; }
            .time-slot { padding: 6px; min-height: 45px; margin-bottom: 4px; }
            .floating-add-btn { bottom: 15px; right: 15px; width: 50px; height: 50px; font-size: 22px; }
        }
        
        @media (max-width: 480px) {
            .main-container { padding: 60px 5px 10px; }
            .month-title { font-size: 16px; }
            .day-view-title { font-size: 14px; }
            .section-title { font-size: 12px; }
            .task-text { font-size: 12px; }
            .time-slot-label { font-size: 10px; }
            .calendar-header-left, .calendar-header-right { gap: 6px; }
            .nav-button { width: 30px; height: 30px; font-size: 11px; }
            .view-toggle-btn { padding: 6px 10px; font-size: 10px; }
        }
    </style>
</head>
<body>
    <!-- Loading Overlay -->
    <div id="loadingOverlay" class="loading-overlay" style="display: none;">
        <div class="loading-spinner"></div>
        <div class="loading-text">Loading...</div>
    </div>
    
    <!-- Navigation -->
    <div class="nav-bar">
        <div class="nav-left">
            <div class="mini-orb" onclick="window.location.href='index.html'"></div>
            <div class="nav-menu">
                <a href="index.html" class="nav-item">Chat</a>
                <a href="dashboard.html" class="nav-item">Dashboard</a>
                <a href="lists.html" class="nav-item">Lists</a>
                <a href="calendar.html" class="nav-item active">Calendar</a>
                <a href="journal.html" class="nav-item">Journal</a>
                <button class="more-nav-btn" onclick="openMoreOverlay()">More</button>
            </div>
        </div>
        <div class="nav-right">
            <div class="api-indicator connecting" id="apiStatus">Connecting</div>
            <button class="notifications-btn" onclick="openNotifications()" title="Notifications"></button>
            <button class="settings-btn" onclick="window.location.href='settings.html'" title="Settings"></button>
        </div>
    </div>

    <!-- Main Content -->
    <div class="main-container">
        <!-- Top Info Bar -->
        <div class="top-info-bar">
            <div class="time-display">
                <div class="current-time" id="currentTime">Loading...</div>
                <div class="current-date" id="currentDate">Loading...</div>
            </div>
            <div class="weather-widget">
                <div></div>
                <div>23</div>
            </div>
        </div>

        <!-- Calendar Header -->
        <div class="calendar-header">
            <div class="calendar-header-left">
                <button class="nav-button" onclick="previousMonth()"></button>
            </div>
            <div class="calendar-header-center">
                <h1 class="month-title" id="currentMonth">Loading...</h1>
            </div>
            <div class="calendar-header-right">
                <button class="nav-button" onclick="nextMonth()"></button>
                <div class="view-toggle">
                    <button class="view-toggle-btn active" onclick="switchView('month')" id="monthViewBtn">Month</button>
                    <button class="view-toggle-btn" onclick="switchView('day')" id="dayViewBtn">Day</button>
                </div>
            </div>
        </div>

        <!-- Day View -->
        <div class="day-view" id="dayView">
            <div class="day-view-layout">
                <!-- Left Side: Day Schedule -->
                <div class="day-events">
                    <div class="day-timeline" id="dayTimeline">
                        <!-- Timeline will be generated here -->
                    </div>
                </div>
                
                <!-- Right Side: Available Tasks -->
                <div class="day-tasks">
                    <div class="section-title">
                         Available Tasks
                        <div class="task-filter-buttons">
                            <button class="filter-btn" id="allTasksBtn" onclick="setTaskFilter('all')">All</button>
                            <button class="filter-btn" id="workTasksBtn" onclick="setTaskFilter('work')">Work</button>
                            <button class="filter-btn" id="personalTasksBtn" onclick="setTaskFilter('personal')">Personal</button>
                        </div>
                    </div>
                    <div id="dayTasksList">
                        <div class="no-events">Loading tasks...</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Calendar Layout -->
        <div class="calendar-layout" id="monthView">
            <div class="calendar-grid" id="calendarGrid">
                <div style="grid-column: 1/-1; text-align: center; padding: 40px; color: #666;">
                    Loading calendar...
                </div>
            </div>

            <div class="right-panel">
                <div class="panel-content" id="panelContent">
                    <div class="events-list" id="eventsList">
                        <div class="no-events">Select a date to view events</div>
                    </div>
                    
                    <!-- Reminders Section -->
                    <div class="reminders-section" id="remindersSection" style="display: none;">
                        <div class="reminders-list" id="remindersList">
                            <div class="no-reminders">No reminders for this date</div>
                        </div>
                    </div>
                </div>

                <div class="panel-footer" id="panelFooter" style="display: none;">
                    <div class="day-summary">
                        <div class="summary-stat">
                            <span class="stat-number-small" id="eventCount">0</span>
                            <span class="stat-label-small">events</span>
                        </div>
                        <div class="summary-stat">
                            <span class="stat-number-small" id="freeHours">8</span>
                            <span class="stat-label-small">free hours</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

        <!-- Link Item Modal -->
        <div class="link-item-modal" id="linkItemModal">
            <div class="link-item-content">
                <div class="link-item-header">
                    <h3 class="link-item-title"> Link Item to Event</h3>
                    <button class="link-item-close" onclick="closeLinkItemModal()"></button>
                </div>
                <div class="link-item-body">
                    <div class="link-item-field">
                        <label class="link-item-label">List Type</label>
                        <select class="link-item-input" id="linkListType">
                            <option value="shopping"> Shopping</option>
                            <option value="personal_todos"> Personal Todos</option>
                            <option value="work_todos"> Work Todos</option>
                            <option value="bucket"> Bucket List</option>
                        </select>
                    </div>
                    <div class="link-item-field">
                        <label class="link-item-label">Item Text</label>
                        <input type="text" class="link-item-input" id="linkItemText" placeholder="e.g., Buy roast chicken">
                    </div>
                    <div class="link-item-field">
                        <label class="link-item-label">When to Add</label>
                        <select class="link-item-input" id="linkWhenToAdd">
                            <option value="immediately">Immediately</option>
                            <option value="1_week_before">1 week before event</option>
                            <option value="2_weeks_before">2 weeks before event</option>
                            <option value="3_days_before">3 days before event</option>
                            <option value="1_day_before">1 day before event</option>
                        </select>
                    </div>
                    <div class="link-item-field">
                        <label class="link-item-label">Priority</label>
                        <select class="link-item-input" id="linkItemPriority">
                            <option value="low">Low</option>
                            <option value="medium" selected>Medium</option>
                            <option value="high">High</option>
                            <option value="critical">Critical</option>
                        </select>
                    </div>
                    <div class="link-item-actions">
                        <button class="link-item-cancel" onclick="closeLinkItemModal()">Cancel</button>
                        <button class="link-item-save" onclick="addLinkToEvent()">Add Link</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Notifications Panel -->
        <div class="notifications-panel" id="notificationsPanel">
            <div class="notifications-header">
                <h3 class="notifications-title"> Notifications</h3>
                <button class="notifications-close" onclick="closeNotifications()"></button>
            </div>
            <div class="notifications-content" id="notificationsContent">
                <div class="no-notifications">No notifications</div>
        </div>
    </div>

    <!-- More Overlay -->
    <div class="more-overlay" id="moreOverlay">
        <div class="more-content">
            <button class="more-close" onclick="closeMoreOverlay()"></button>
            <div class="more-header">
                <h2 class="more-title">More Options</h2>
            </div>
            <div class="more-grid">
                <div class="more-item" onclick="navigateToPage('memories.html')">
                    <div class="more-item-icon"></div>
                    <div class="more-item-label">Memories</div>
                </div>
                <div class="more-item" onclick="navigateToPage('workflows.html')">
                    <div class="more-item-icon"></div>
                    <div class="more-item-label">Workflows</div>
                </div>
                <div class="more-item" onclick="navigateToPage('settings.html')">
                    <div class="more-item-icon"></div>
                    <div class="more-item-label">Settings</div>
                </div>
                <div class="more-item" onclick="alert('Coming soon!')">
                    <div class="more-item-icon"></div>
                    <div class="more-item-label">Analytics</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Item Details Overlay -->
    <div class="item-details-overlay" id="itemDetailsOverlay">
        <div class="item-details-content">
            <div class="item-details-header">
                <h3 class="item-details-title" id="itemDetailsTitle">Item Details</h3>
                <button class="item-details-close" onclick="closeItemDetails()"></button>
            </div>
            <div class="item-details-body" id="itemDetailsBody">
                <!-- Dynamic content will be inserted here -->
            </div>
            <div class="item-details-actions" id="itemDetailsActions">
                <!-- Dynamic buttons will be inserted here -->
            </div>
        </div>
    </div>

    <!-- Add Event Options Overlay -->
    <div class="add-options-overlay" id="addOptionsOverlay">
        <div class="add-options-content">
            <button class="add-options-close" onclick="closeAddOptions()"></button>
            <div class="add-options-header">
                <h3 class="add-options-title">Add Event</h3>
            </div>
            <div class="add-options-grid">
                <div class="add-option-item" onclick="openEnhancedAddForm()">
                    <div class="add-option-icon"></div>
                    <div class="add-option-text">Enhanced Form</div>
                </div>
                <div class="add-option-item" onclick="openAIChat()">
                    <div class="add-option-icon"></div>
                    <div class="add-option-text">Chat with AI</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Enhanced Add Event Form -->
    <div class="enhanced-add-overlay" id="enhancedAddOverlay">
        <div class="enhanced-add-content">
            <div class="enhanced-add-header">
                <h3 class="enhanced-add-title">Add Event</h3>
                <button class="enhanced-add-close" onclick="closeEnhancedAddForm()"></button>
            </div>
            
            <div class="enhanced-add-layout">
                <!-- Manual Form Section -->
                <div class="enhanced-form-section">
                    <!-- Toggle between Event and Reminder -->
                    <div class="add-type-toggle">
                        <button class="toggle-btn active" id="toggleEvent" onclick="toggleAddType('event')"> Event</button>
                        <button class="toggle-btn" id="toggleReminder" onclick="toggleAddType('reminder')"> Reminder</button>
                    </div>
                    <h4 class="enhanced-form-title" id="formTitle"> Event Details</h4>
                    <div class="enhanced-form-field">
                        <label class="enhanced-form-label">Event Title</label>
                        <input type="text" class="enhanced-form-input" id="enhancedEventTitle" placeholder="Enter event title">
                    </div>
                    <div class="enhanced-form-row">
                        <div class="enhanced-form-field">
                            <label class="enhanced-form-label">Date</label>
                            <input type="date" class="enhanced-form-input" id="enhancedEventDate">
                        </div>
                        <div class="enhanced-form-field">
                            <label class="enhanced-form-label">Start Time</label>
                            <input type="time" class="enhanced-form-input" id="enhancedEventTime">
                        </div>
                    </div>
                    <div class="enhanced-form-row">
                        <div class="enhanced-form-field">
                            <label class="enhanced-form-label">Duration</label>
                            <select class="enhanced-form-input" id="enhancedEventDuration">
                                <option value="15">15 minutes</option>
                                <option value="30" selected>30 minutes</option>
                                <option value="60">1 hour</option>
                                <option value="90">1.5 hours</option>
                                <option value="120">2 hours</option>
                                <option value="180">3 hours</option>
                                <option value="240">4 hours</option>
                                <option value="480">8 hours (all day)</option>
                            </select>
                        </div>
                        <div class="enhanced-form-field">
                            <label class="enhanced-form-label">Category</label>
                            <select class="enhanced-form-input" id="enhancedEventCategory">
                                <option value="personal">Personal</option>
                                <option value="work">Work</option>
                                <option value="health">Health</option>
                                <option value="social">Social</option>
                                <option value="family">Family</option>
                                <option value="routine">Routine (Daily Tasks)</option>
                            </select>
                        </div>
                    </div>
                    <div class="enhanced-form-row">
                        <div class="enhanced-form-field">
                            <label class="enhanced-form-label">Recurring</label>
                            <select class="enhanced-form-input" id="enhancedEventRecurring">
                                <option value="">No recurrence</option>
                                <option value="daily">Daily</option>
                                <option value="weekly">Weekly</option>
                                <option value="monthly">Monthly</option>
                                <option value="yearly">Yearly</option>
                            </select>
                        </div>
                        <div class="enhanced-form-field" id="recurringIntervalField" style="display: none;">
                            <label class="enhanced-form-label">Every</label>
                            <select class="enhanced-form-input" id="enhancedEventRecurringInterval">
                                <option value="1">1</option>
                                <option value="2">2</option>
                                <option value="3">3</option>
                                <option value="4">4</option>
                                <option value="6">6</option>
                                <option value="12">12</option>
                            </select>
                        </div>
                    </div>
                    <div class="enhanced-form-field" id="recurringEndField" style="display: none;">
                        <label class="enhanced-form-label">End Date (optional)</label>
                        <input type="date" class="enhanced-form-input" id="enhancedEventRecurringEnd">
                    </div>
                    <div class="enhanced-form-checkbox">
                        <input type="checkbox" id="enhancedAllDay" onchange="toggleAllDay()">
                        <label for="enhancedAllDay">All-day event</label>
                    </div>
                    <div class="enhanced-form-field">
                        <label class="enhanced-form-label">Description (Optional)</label>
                        <textarea class="enhanced-form-input" id="enhancedEventDescription" rows="3" placeholder="Add event description..."></textarea>
                    </div>
                    
                    <!-- Reminder-specific fields -->
                    <div id="reminderFields" style="display: none;">
                        <div class="enhanced-form-row">
                            <div class="enhanced-form-field">
                                <label class="enhanced-form-label">Priority</label>
                                <select class="enhanced-form-input" id="enhancedReminderPriority">
                                    <option value="low">Low</option>
                                    <option value="medium" selected>Medium</option>
                                    <option value="high">High</option>
                                    <option value="critical">Critical</option>
                                </select>
                            </div>
                            <div class="enhanced-form-field">
                                <label class="enhanced-form-label">Reminder Type</label>
                                <select class="enhanced-form-input" id="enhancedReminderType">
                                    <option value="once" selected>Once</option>
                                    <option value="daily">Daily</option>
                                    <option value="weekly">Weekly</option>
                                    <option value="monthly">Monthly</option>
                                </select>
                            </div>
                        </div>
                        <div class="enhanced-form-checkbox">
                            <input type="checkbox" id="enhancedRequiresAck">
                            <label for="enhancedRequiresAck">Requires acknowledgment</label>
                    </div>
                </div>
                
                    <!-- Event reminders section -->
                    <div id="eventRemindersSection" style="display: none;">
                        <div class="enhanced-form-field">
                            <label class="enhanced-form-label">Event Reminders</label>
                            <div id="eventRemindersList" class="reminders-list">
                                <div class="no-reminders">No reminders added yet</div>
                            </div>
                            <button type="button" class="add-reminder-to-event-btn" onclick="addReminderToEvent()">+ Add Reminder</button>
                        </div>
                        
                        <!-- Cross-linking section -->
                        <div class="enhanced-form-field">
                            <label class="enhanced-form-label"> Link to Lists</label>
                            <div id="eventLinksList" class="links-list">
                                <div class="no-links">No items linked yet</div>
                            </div>
                            <button type="button" class="add-link-to-event-btn" onclick="showLinkItemModal()">+ Link Item</button>
                        </div>
                    </div>
                </div>
                
                <!-- Voice Assistant Section -->
                <div class="enhanced-form-section ai-chat-section">
                    <h4 class="enhanced-form-title"> Voice Assistant</h4>
                    <div class="ai-chat-orb" onclick="toggleVoiceInput()">
                        
                    </div>
                    <div class="ai-chat-text">
                        Press to talk
                    </div>
                    <div class="voice-conversation" id="voiceConversation" style="display: none;">
                        <div class="conversation-item user" id="userMessage" style="display: none;">
                            <strong>You:</strong> <span id="userText"></span>
                        </div>
                        <div class="conversation-item assistant" id="assistantMessage" style="display: none;">
                            <strong>Zoe:</strong> <span id="assistantText"></span>
                        </div>
                    </div>
                </div>
            </div>
            <div class="enhanced-form-actions">
                <button class="enhanced-form-btn secondary" onclick="closeEnhancedAddForm()">Cancel</button>
                <button class="enhanced-form-btn primary" onclick="saveEnhancedEvent()" id="enhancedEventSaveBtn">Create Event</button>
            </div>
        </div>
    </div>

    <!-- Floating Add Button -->
    <button class="floating-add-btn" onclick="openEnhancedAddForm()" title="Add Event">+</button>

    <script src="js/common.js"></script>
    <script src="js/ai-processor.js"></script>
    <script>
        // Lightweight GET cache and in-flight deduplication
        const __apiGetCache = new Map(); // key -> { timestamp, ttl, data }
        const __apiInFlight = new Map(); // key -> Promise
        function apiGetCached(path, ttlMs = 30000) {
            const key = path;
            const now = Date.now();
            const cached = __apiGetCache.get(key);
            if (cached && (now - cached.timestamp) < cached.ttl) {
                return Promise.resolve(cached.data);
            }
            if (__apiInFlight.has(key)) {
                return __apiInFlight.get(key);
            }
            const p = apiRequest(path)
                .then(data => {
                    __apiGetCache.set(key, { timestamp: Date.now(), ttl: ttlMs, data });
                    __apiInFlight.delete(key);
                    return data;
                })
                .catch(err => {
                    __apiInFlight.delete(key);
                    throw err;
                });
            __apiInFlight.set(key, p);
            return p;
        }
        let currentDate = new Date();
        let selectedDate = null;
        let allEvents = [];
        let allTasks = [];
        let currentView = 'month';
        let currentDayView = new Date();
        let currentTaskFilter = 'all'; // 'all', 'work', 'personal'
        
        // Performance optimization: Caching
        let eventCache = new Map();
        let taskCache = new Map();
        let reminderCache = new Map();
        let cacheTimeout = 5 * 60 * 1000; // 5 minutes
        
        // Cache management functions
        function getCachedData(cache, key) {
            const cached = cache.get(key);
            if (cached && Date.now() - cached.timestamp < cacheTimeout) {
                return cached.data;
            }
            return null;
        }
        
        function setCachedData(cache, key, data) {
            cache.set(key, {
                data: data,
                timestamp: Date.now()
            });
        }
        
        function clearCache(cache) {
            cache.clear();
        }
        
        // Invalidate specific cache entries
        function invalidateCache(cache, key) {
            if (key) {
                cache.delete(key);
            } else {
                cache.clear();
            }
        }
        
        // Debounce function for API calls
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }
        
        // Debounced refresh functions
        // Never force reload on debounce to keep UI snappy
        const debouncedLoadEvents = debounce(() => loadEvents(false), 300);
        const debouncedLoadTasks = debounce(() => loadTasksForDay(true), 300);
        
        // Loading state management
        function showLoading(elementId, show = true) {
            const element = document.getElementById(elementId);
            if (element) {
                if (show) {
                    element.classList.add('loading');
                    element.style.opacity = '0.6';
                } else {
                    element.classList.remove('loading');
                    element.style.opacity = '1';
                }
            }
        }
        
        // Disable global loading overlay for performance; keep function no-op
        function showGlobalLoading(show = true) {
            const loadingOverlay = document.getElementById('loadingOverlay');
            if (loadingOverlay) {
                // No-op to avoid blocking UI with overlays
                loadingOverlay.style.display = 'none';
            }
        }
        
        // Centralized error handling
        function handleError(error, context = 'Unknown operation') {
            console.error(`Error in ${context}:`, error);
            
            let userMessage = 'An unexpected error occurred. Please try again.';
            
            if (error.message) {
                if (error.message.includes('Failed to fetch')) {
                    userMessage = 'Unable to connect to the server. Please check your internet connection.';
                } else if (error.message.includes('404')) {
                    userMessage = 'The requested resource was not found.';
                } else if (error.message.includes('500')) {
                    userMessage = 'Server error. Please try again later.';
                } else if (error.message.includes('403')) {
                    userMessage = 'You do not have permission to perform this action.';
                } else if (error.message.includes('400')) {
                    userMessage = 'Invalid request. Please check your input and try again.';
                } else {
                    userMessage = error.message;
                }
            }
            
            showNotification(userMessage, 'error');
            
            // Update API status to offline if it's a network error
            if (error.message && error.message.includes('Failed to fetch')) {
                const apiStatus = document.getElementById('apiStatus');
                if (apiStatus) {
                    apiStatus.textContent = 'Offline';
                    apiStatus.className = 'api-indicator offline';
                }
            }
        }
        
        // Input validation functions
        function validateEventData(eventData) {
            const errors = [];
            
            if (!eventData.title || eventData.title.trim().length === 0) {
                errors.push('Event title is required');
            }
            
            if (!eventData.start_date) {
                errors.push('Start date is required');
            }
            
            if (!eventData.all_day && !eventData.start_time) {
                errors.push('Start time is required for timed events');
            }
            
            if (eventData.start_date && eventData.start_time) {
                const eventDateTime = new Date(`${eventData.start_date}T${eventData.start_time}`);
                if (eventDateTime < new Date()) {
                    errors.push('Event cannot be scheduled in the past');
                }
            }
            
            return errors;
        }
        
        function validateTaskData(taskData) {
            const errors = [];
            
            if (!taskData.text || taskData.text.trim().length === 0) {
                errors.push('Task description is required');
            }
            
            if (taskData.text && taskData.text.trim().length > 500) {
                errors.push('Task description must be less than 500 characters');
            }
            
            return errors;
        }
        
        function showValidationErrors(errors) {
            if (errors.length > 0) {
                showNotification(errors.join('. '), 'error');
                return false;
            }
            return true;
        }
        
        // Calendar settings (will be loaded from user settings)
        let calendarSettings = {
            workHours: { start: '09:00', end: '17:00' },
            defaultView: 'month',
            showWorkTasks: true,
            showPersonalTasks: true,
            showAllDayEvents: true,
            timeSlotInterval: 60 // minutes
        };

        function formatDate(date) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        function formatTime(timeStr) {
            if (!timeStr) return '';
            const [hours, minutes] = timeStr.split(':');
            const hour12 = hours % 12 || 12;
            const ampm = hours >= 12 ? 'PM' : 'AM';
            return `${hour12}:${minutes} ${ampm}`;
        }

        function updateCalendar() {
            updateCalendarHeader();
            generateCalendarGrid();
        }

        function updateCalendarHeader() {
            const monthNames = [
                'January', 'February', 'March', 'April', 'May', 'June',
                'July', 'August', 'September', 'October', 'November', 'December'
            ];
            document.getElementById('currentMonth').textContent = 
                `${monthNames[currentDate.getMonth()]} ${currentDate.getFullYear()}`;
        }

        function generateCalendarGrid() {
            const grid = document.getElementById('calendarGrid');
            grid.innerHTML = '';
            
            const dayHeaders = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
            dayHeaders.forEach(day => {
                const headerDiv = document.createElement('div');
                headerDiv.className = 'day-header';
                headerDiv.textContent = day;
                grid.appendChild(headerDiv);
            });
            
            const firstDay = new Date(currentDate.getFullYear(), currentDate.getMonth(), 1);
            const startDate = new Date(firstDay);
            startDate.setDate(startDate.getDate() - firstDay.getDay());
            
            const today = formatDate(new Date());
            
            for (let i = 0; i < 42; i++) {
                const cellDate = new Date(startDate);
                cellDate.setDate(startDate.getDate() + i);
                
                const cellDateStr = formatDate(cellDate);
                const isCurrentMonth = cellDate.getMonth() === currentDate.getMonth();
                const isToday = cellDateStr === today;
                
                const hasEvents = allEvents.some(event => 
                    ((event.start_date === cellDateStr) || (event.date === cellDateStr)) &&
                    event.category !== 'routine'
                );
                
                const dayDiv = document.createElement('div');
                dayDiv.className = 'calendar-day';
                if (isToday) dayDiv.classList.add('today');
                if (hasEvents) dayDiv.classList.add('has-event');
                if (!isCurrentMonth) dayDiv.classList.add('other-month');
                if (selectedDate === cellDateStr) dayDiv.classList.add('selected');
                
                dayDiv.setAttribute('data-date', cellDateStr);
                dayDiv.textContent = cellDate.getDate();
                dayDiv.onclick = () => selectDate(cellDateStr);
                
                grid.appendChild(dayDiv);
            }
        }

        function selectDate(dateStr) {
            selectedDate = dateStr;
            
            document.querySelectorAll('.calendar-day').forEach(d => d.classList.remove('selected'));
            document.querySelectorAll('.calendar-day').forEach(d => {
                if (d.getAttribute('data-date') === dateStr) {
                    d.classList.add('selected');
                }
            });
            
            updateDayView(dateStr);
        }

        function updateDayView(dateStr) {
            const eventsListEl = document.getElementById('eventsList');
            const panelFooter = document.getElementById('panelFooter');
            const monthTitle = document.getElementById('currentMonth');
            
            const [year, month, day] = dateStr.split('-');
            const dateObj = new Date(parseInt(year), parseInt(month) - 1, parseInt(day));
            const today = formatDate(new Date());
            const isToday = dateStr === today;
            
            // Update month title with selected date
            if (isToday) {
                monthTitle.textContent = 'Today';
            } else {
                const monthNames = [
                    'January', 'February', 'March', 'April', 'May', 'June',
                    'July', 'August', 'September', 'October', 'November', 'December'
                ];
                monthTitle.textContent = `${monthNames[dateObj.getMonth()]} ${dateObj.getDate()}, ${dateObj.getFullYear()}`;
            }
            
            const dayEvents = allEvents.filter(event => 
                (event.start_date === dateStr) || (event.date === dateStr)
            );
            
            panelFooter.style.display = 'block';
            
            if (dayEvents.length === 0) {
                eventsListEl.innerHTML = '<div class="no-events">No events scheduled</div>';
            } else {
                let html = '';
                
                dayEvents.forEach(event => {
                    const category = event.category || 'personal';
                    const timeStr = event.start_time || event.time;
                    
                    html += `
                        <div class="event-item category-${category}" onclick="showEventDetails(${event.id})">
                            ${timeStr ? `<div class="event-time">${formatTime(timeStr)}</div>` : ''}
                            <div class="event-title">${event.title}</div>
                        </div>
                    `;
                });
                eventsListEl.innerHTML = html;
            }
            
            document.getElementById('eventCount').textContent = dayEvents.length;
            document.getElementById('freeHours').textContent = Math.max(0, 8 - dayEvents.length);
            
            // Load reminders for this date
            loadReminders(dateStr);
        }

        async function previousMonth() {
            if (currentView === 'month') {
                currentDate.setMonth(currentDate.getMonth() - 1);
                updateCalendar();
            } else {
                currentDayView.setDate(currentDayView.getDate() - 1);
                await updateDayViewDisplay(false);
                updateCalendarHeaderForDay();
            }
        }

        async function nextMonth() {
            if (currentView === 'month') {
                currentDate.setMonth(currentDate.getMonth() + 1);
                updateCalendar();
            } else {
                currentDayView.setDate(currentDayView.getDate() + 1);
                await updateDayViewDisplay(false);
                updateCalendarHeaderForDay();
            }
        }

        function selectEvent(eventId) {
            const event = allEvents.find(e => e.id === eventId);
            if (event) {
                showNotification(`Selected: ${event.title}`);
            }
        }

        async function editEvent(eventId) {
            const event = allEvents.find(e => e.id === eventId);
            if (event) {
                const newTitle = prompt('Edit event title:', event.title);
                if (newTitle !== null && newTitle.trim() !== '') {
                    try {
                        const updatedEvent = await updateEvent(eventId, {
                            ...event,
                            title: newTitle.trim()
                        });
                        
                        // Update local array
                        const index = allEvents.findIndex(e => e.id === eventId);
                        allEvents[index] = updatedEvent;
                        
                        updateCalendar();
                        if (selectedDate) {
                            updateDayView(selectedDate);
                        }
                        showNotification('Event updated');
                    } catch (error) {
                        showNotification('Failed to update event', 'error');
                    }
                }
            }
        }

        async function deleteEvent(eventId) {
            if (confirm('Delete this event?')) {
                try {
                    await deleteEventFromAPI(eventId);
                    allEvents = allEvents.filter(e => e.id !== eventId);
                    updateCalendar();
                    if (selectedDate) {
                        updateDayView(selectedDate);
                    }
                    showNotification('Event deleted');
                } catch (error) {
                    showNotification('Failed to delete event', 'error');
                }
            }
        }

        async function addEvent() {
            // Create a simple form dialog
            const form = document.createElement('div');
            form.innerHTML = `
                <div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; z-index: 10000;">
                    <div style="background: white; padding: 20px; border-radius: 12px; max-width: 400px; width: 90%;">
                        <h3 style="margin-bottom: 15px; color: #333;">Add Event</h3>
                        <input type="text" id="eventTitle" placeholder="Event title" style="width: 100%; padding: 10px; margin-bottom: 10px; border: 1px solid #ddd; border-radius: 6px;">
                        <input type="time" id="eventTime" style="width: 100%; padding: 10px; margin-bottom: 10px; border: 1px solid #ddd; border-radius: 6px;">
                        <label style="display: flex; align-items: center; margin-bottom: 15px;">
                            <input type="checkbox" id="allDayCheckbox" style="margin-right: 8px;">
                            All-day event
                        </label>
                        <select id="eventCategory" style="width: 100%; padding: 10px; margin-bottom: 15px; border: 1px solid #ddd; border-radius: 6px;">
                            <option value="personal">Personal</option>
                            <option value="work">Work</option>
                            <option value="health">Health</option>
                            <option value="social">Social</option>
                            <option value="family">Family</option>
                        </select>
                        <div style="display: flex; gap: 10px; justify-content: flex-end;">
                            <button onclick="this.closest('div').remove()" style="padding: 8px 16px; border: 1px solid #ddd; background: white; border-radius: 6px; cursor: pointer;">Cancel</button>
                            <button onclick="saveEventFromForm()" style="padding: 8px 16px; background: #7B61FF; color: white; border: none; border-radius: 6px; cursor: pointer;">Save</button>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(form);
            
            // Focus on title input
            setTimeout(() => document.getElementById('eventTitle').focus(), 100);
            
            // Toggle time input based on all-day checkbox
            document.getElementById('allDayCheckbox').addEventListener('change', function() {
                const timeInput = document.getElementById('eventTime');
                timeInput.style.display = this.checked ? 'none' : 'block';
            });
        }

        async function saveEventFromForm() {
            const title = document.getElementById('eventTitle').value.trim();
            const time = document.getElementById('eventTime').value;
            const allDay = document.getElementById('allDayCheckbox').checked;
            const category = document.getElementById('eventCategory').value;
            
            if (!title) {
                alert('Please enter an event title');
                return;
            }
            
            if (!allDay && !time) {
                alert('Please enter a time or check all-day event');
                return;
            }
            
            const date = selectedDate || formatDate(new Date());
            
            const eventData = {
                title: title,
                start_date: date,
                start_time: allDay ? null : time,
                duration: allDay ? 480 : 30, // 8 hours for all-day, 30 minutes default
                all_day: allDay,
                category: category
            };
            
            try {
                const newEvent = await saveEvent(eventData);
                allEvents.push(newEvent);
                updateCalendar();
                if (currentView === 'day') {
                    await updateDayViewDisplay(false);
                }
                showNotification('Event added');
                
                // Event is already saved via saveEvent, no need for ensurePersistence
                
                // Remove the form
                document.querySelector('div[style*="position: fixed"]').remove();
            } catch (error) {
                showNotification('Failed to add event', 'error');
            }
        }

        function navigateToPage(page) {
            window.location.href = page;
        }

        // View switching functions
        async function switchView(view) {
            currentView = view;
            
            // Update toggle buttons
            document.querySelectorAll('.view-toggle-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(view + 'ViewBtn').classList.add('active');
            
            // Show/hide views
            const monthView = document.getElementById('monthView');
            const dayView = document.getElementById('dayView');
            
            if (view === 'month') {
                monthView.style.display = 'grid';
                dayView.classList.remove('active');
                updateCalendarHeader();
                updateCalendar();
            } else {
                // Ensure currentDayView is set to today when switching to day view
                const today = new Date();
                const todayStr = formatDate(today);
                if (!currentDayView || formatDate(currentDayView) !== todayStr) {
                    currentDayView = today;
                }
                
                monthView.style.display = 'none';
                dayView.classList.add('active');
                await updateDayViewDisplay(false);
                updateCalendarHeaderForDay();
            }
        }

        function updateCalendarHeaderForDay() {
            const monthTitle = document.getElementById('currentMonth');
            const dateStr = formatDate(currentDayView);
            const dateObj = new Date(currentDayView);
            const today = formatDate(new Date());
            const isToday = dateStr === today;
            
            if (isToday) {
                monthTitle.textContent = 'Today';
            } else {
                monthTitle.textContent = dateObj.toLocaleDateString('en-US', { 
                    month: 'long', 
                    day: 'numeric', 
                    year: 'numeric' 
                });
            }
        }

        async function updateDayViewDisplay(forceRefreshEvents = false) {
            // Load events, tasks and generate time slots
            if (forceRefreshEvents) {
                // Only refresh events without showing global loading
                await loadEvents(false); // Don't force refresh to avoid loading screen
            } else {
                await loadEvents(false);
            }
            loadTasksForDay();
            generateTimeSlots();
        }
        
        // Manual scroll test function for debugging
        function testScroll() {
            const eventsArea = document.getElementById('eventsArea');
            if (eventsArea) {
                console.log('Events area found, scrollHeight:', eventsArea.scrollHeight, 'clientHeight:', eventsArea.clientHeight);
                eventsArea.scrollTop = 500; // Test scroll to 500px
                console.log('Scrolled to 500px, current scrollTop:', eventsArea.scrollTop);
            } else {
                console.error('Events area not found');
            }
        }

        // Task management functions
        async function loadTasksForDay(forceRefresh = false) {
            try {
                const cacheKey = 'tasks';
                let tasks = null;
                
                if (!forceRefresh) {
                    tasks = getCachedData(taskCache, cacheKey);
                }
                
                if (!tasks) {
                    // Load both personal and work todos (cached)
                    const [personalResponse, workResponse] = await Promise.all([
                        apiGetCached('/lists/personal_todos', 15000),
                        apiGetCached('/lists/work_todos', 15000)
                    ]);
                    
                    const personalLists = personalResponse.lists || [];
                    const workLists = workResponse.lists || [];
                    
                    // Flatten all tasks from all lists
                    tasks = [];
                    
                    // Process personal todos
                    personalLists.forEach(list => {
                        if (list.items && Array.isArray(list.items)) {
                            list.items.forEach(item => {
                                if (!item.completed) { // Only show incomplete tasks
                                    tasks.push({
                                        ...item,
                                        listId: list.id,
                                        listName: list.name,
                                        category: 'personal'
                                    });
                                }
                            });
                        }
                    });
                    
                    // Process work todos
                    workLists.forEach(list => {
                        if (list.items && Array.isArray(list.items)) {
                            list.items.forEach(item => {
                                if (!item.completed) { // Only show incomplete tasks
                                    tasks.push({
                                        ...item,
                                        listId: list.id,
                                        listName: list.name,
                                        category: 'work'
                                    });
                                }
                            });
                        }
                    });
                    
                    setCachedData(taskCache, cacheKey, tasks);
                }
                
                allTasks = tasks;
                displayTasks();
            } catch (error) {
                handleError(error, 'loading tasks');
                // Show demo tasks
                allTasks = [
                    { id: 1, text: 'Review project proposal', priority: 'high', listName: 'Work Todos', category: 'work' },
                    { id: 2, text: 'Buy groceries', priority: 'medium', listName: 'Personal Todos', category: 'personal' },
                    { id: 3, text: 'Call dentist', priority: 'low', listName: 'Personal Todos', category: 'personal' },
                    { id: 4, text: 'Finish presentation', priority: 'high', listName: 'Work Todos', category: 'work' }
                ];
                displayTasks();
            }
        }

        function displayTasks() {
            const dayTasksList = document.getElementById('dayTasksList');
            
            // First filter by settings, then by current filter
            let filteredTasks = allTasks.filter(task => {
                const isWorkTask = task.category === 'work' || task.listName.toLowerCase().includes('work');
                const isPersonalTask = task.category === 'personal' || !isWorkTask;
                
                // Apply settings filter first
                if (!calendarSettings.showWorkTasks && isWorkTask) return false;
                if (!calendarSettings.showPersonalTasks && isPersonalTask) return false;
                
                // Apply current filter
                if (currentTaskFilter === 'work') return isWorkTask;
                if (currentTaskFilter === 'personal') return isPersonalTask;
                return true; // 'all'
            });
            
            if (filteredTasks.length === 0) {
                dayTasksList.innerHTML = '<div class="no-events">No tasks available</div>';
                return;
            }
            
            let html = '';
            filteredTasks.forEach(task => {
                const taskCategory = task.category === 'work' ? 'work' : 'personal';
                const isCompleted = task.completed || false;
                html += `
                    <div class="task-item category-${taskCategory} ${isCompleted ? 'completed' : ''}" 
                         draggable="true" 
                         data-task-id="${task.id}" 
                         data-task-text="${task.text}" 
                         data-task-priority="${task.priority}" 
                         onclick="showTaskDetails(${task.id})">
                        <div class="task-checkbox" onclick="event.stopPropagation(); toggleTaskCompletion(${task.id})">
                            <input type="checkbox" ${isCompleted ? 'checked' : ''} onchange="toggleTaskCompletion(${task.id})">
                        </div>
                        <div class="task-text">${task.text}</div>
                        <div class="priority-dot ${task.priority}"></div>
                    </div>
                `;
            });
            dayTasksList.innerHTML = html;
            
            // Add drag event listeners
            addDragListeners();
        }

        function setTaskFilter(filter) {
            currentTaskFilter = filter;
            
            // Update button states
            document.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(filter + 'TasksBtn').classList.add('active');
            
            // Refresh task display
            displayTasks();
        }

        function generateTimeSlots() {
            const dayTimeline = document.getElementById('dayTimeline');
            const dateStr = formatDate(currentDayView);
            
            // Get events and reminders for this day
            const dayEvents = allEvents.filter(event => (event.start_date === dateStr) || (event.date === dateStr));
            const dayReminders = window.currentDayReminders || [];
            
            // Initialize static timeline (labels + grid) only once per date
            const needsInit = !dayTimeline.querySelector('#timelineEvents') || window.timelineInitializedDate !== dateStr;
            if (needsInit) {
                let timeLabelsHtml = '';
                let gridHtml = '';
                for (let hour = 0; hour < 24; hour++) {
                    const timeLabel = formatTime(`${hour.toString().padStart(2, '0')}:00`);
                    const topPosition = hour * 60; // 60px per hour
                    timeLabelsHtml += `<div class="timeline-label">${timeLabel}</div>`;
                    gridHtml += `<div class="time-line hour" style="top: ${topPosition}px;"></div>`;
                    gridHtml += `<div class="time-line" style="top: ${topPosition + 30}px;"></div>`;
                }
                dayTimeline.innerHTML = `
                    <div class="timeline-labels">${timeLabelsHtml}</div>
                    <div class="timeline-events" id="timelineEvents">${gridHtml}</div>
                `;
                window.timelineInitializedDate = dateStr;
                // Scroll once on init
                requestAnimationFrame(scrollToCurrentTime);
                // Re-attach drop listeners after reinit
                addDropListeners();
            }
            
            // Render dynamic items (current time + events + reminders)
            const eventsContainer = dayTimeline.querySelector('#timelineEvents');
            if (!eventsContainer) return;
            let eventsHtml = '';
            const now = new Date();
            const currentTimeTop = (now.getHours() * 60) + now.getMinutes();
            eventsHtml += `<div class="current-time-line" style="top: ${currentTimeTop}px;"></div>`;
            
            dayEvents.forEach(event => {
                if (!event.all_day && event.start_time) {
                    const [startHour, startMin] = event.start_time.split(':').map(Number);
                    const duration = event.duration || 30;
                    const startTop = (startHour * 60) + startMin;
                    eventsHtml += `
                        <div class="scheduled-task category-${event.category || 'personal'}" 
                             data-event-id="${event.id}" 
                             style="top: ${startTop}px; height: ${duration}px;"
                             draggable="true"
                             ondragstart="startEventDrag(event)"
                             onclick="openEventEditForm(${event.id})">
                            <div class="task-text">${event.title}</div>
                        </div>
                    `;
                }
            });
            
            dayReminders.forEach(reminder => {
                if (reminder.due_time) {
                    const [hour, min] = reminder.due_time.split(':').map(Number);
                    const reminderTop = (hour * 60) + min;
                    eventsHtml += `
                        <div class="scheduled-task category-${reminder.category || 'personal'} reminder-item priority-${reminder.priority || 'medium'}" 
                             data-reminder-id="${reminder.id}" 
                             style="top: ${reminderTop}px; height: 30px;"
                             onclick="openReminderEditForm(${reminder.id})">
                            <div class="task-text">${reminder.title} ${getPrioritySymbol(reminder.priority)}</div>
                        </div>
                    `;
                }
            });
            
            // Preserve grid lines by appending dynamic html
            // Extract existing grid lines (everything except dynamic items)
            const staticGrid = eventsContainer.innerHTML.replace(/<div class=\"current-time-line\"[\s\S]*?<\/div>/g, '')
                                                       .replace(/<div class=\"scheduled-task[\s\S]*?<\/div>/g, '');
            eventsContainer.innerHTML = staticGrid + eventsHtml;
        }

        function generateTimeSlotsFromSettings() {
            const startHour = parseInt(calendarSettings.workHours.start.split(':')[0]);
            const endHour = parseInt(calendarSettings.workHours.end.split(':')[0]);
            const interval = calendarSettings.timeSlotInterval || 60;
            
            // Get current time for auto-focus
            const now = new Date();
            const currentHour = now.getHours();
            const currentMinute = now.getMinutes();
            
            // Calculate visible range (previous hour to end of work day)
            const visibleStartHour = Math.max(startHour, currentHour - 1);
            const visibleEndHour = Math.max(endHour, currentHour + 2);
            
            const hours = [];
            for (let hour = visibleStartHour; hour <= visibleEndHour; hour += interval / 60) {
                const hourStr = String(Math.floor(hour)).padStart(2, '0');
                const minuteStr = String((hour % 1) * 60).padStart(2, '0');
                hours.push(`${hourStr}:${minuteStr}`);
            }
            return hours;
        }

        function scrollToCurrentTime() {
            const now = new Date();
            const currentHour = now.getHours();
            const currentMinute = now.getMinutes();
            
            // Calculate scroll position (1 hour before current time, centered in view)
            const currentTimePosition = (currentHour * 60) + currentMinute;
            const eventsAreaHeight = 500; // Max height of events area
            const scrollPosition = Math.max(0, currentTimePosition - (eventsAreaHeight / 2)); // Center current time in view
            
            const dayTimeline = document.getElementById('dayTimeline');
            if (dayTimeline) {
                // Use setTimeout to ensure DOM is ready
                setTimeout(() => {
                    console.log('Scrolling to position:', scrollPosition, 'for time:', currentHour + ':' + currentMinute);
                    
                    // Force scroll to position
                    dayTimeline.scrollTop = scrollPosition;
                    
                    // Verify scroll worked
                    setTimeout(() => {
                        console.log('Final scroll position:', dayTimeline.scrollTop);
                    }, 100);
                }, 300);
            } else {
                console.error('Day timeline not found');
            }
        }

        function addDragListeners() {
            document.querySelectorAll('.task-item').forEach(task => {
                // Desktop drag events
                task.addEventListener('dragstart', handleDragStart);
                task.addEventListener('dragend', handleDragEnd);
                
                // Touch events for mobile
                task.addEventListener('touchstart', handleTouchStart, { passive: false });
                task.addEventListener('touchmove', handleTouchMove, { passive: false });
                task.addEventListener('touchend', handleTouchEnd, { passive: false });
                
                // Prevent click when dragging
                task.addEventListener('click', (e) => {
                    if (isDragging) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                });
                
                // Ensure draggable is set
                task.draggable = true;
            });
        }

        function addDropListeners() {
            const dayTimeline = document.getElementById('dayTimeline');
            if (!dayTimeline) return;
            
            dayTimeline.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
                
                // Add visual feedback for drop zones
                const timeSlot = e.target.closest('.time-slot');
                if (timeSlot) {
                    timeSlot.classList.add('drag-over');
                }
            });
            
            dayTimeline.addEventListener('drop', (e) => {
                e.preventDefault();
                
                // Clean up drag over classes
                document.querySelectorAll('.time-slot').forEach(slot => {
                    slot.classList.remove('drag-over');
                });
                
                const data = e.dataTransfer.getData('text/plain');
                if (data.includes('task-') || draggedTask) {
                    handleDrop(e); // Handle task drops
                } else if (data) {
                    handleEventDrop(e); // Handle event drops
                }
            });
            
            dayTimeline.addEventListener('dragenter', (e) => {
                e.preventDefault();
                handleDragEnter(e);
            });
            
            dayTimeline.addEventListener('dragleave', (e) => {
                e.preventDefault();
                handleDragLeave(e);
            });
            
            // Add click handler for timeline
            dayTimeline.addEventListener('click', (e) => {
                // Don't interfere with event clicks
                if (!e.target.closest('.scheduled-task')) {
                    // Calculate time from click position and snap to half-hour intervals
                    const timelineEvents = dayTimeline.querySelector('.timeline-events');
                    if (!timelineEvents) return;
                    
                    const rect = timelineEvents.getBoundingClientRect();
                    const y = e.clientY - rect.top;
                    
                    // Convert pixel position to time (1 pixel = 1 minute)
                    const totalMinutes = Math.max(0, Math.round(y));
                    const hour = Math.floor(totalMinutes / 60);
                    const minute = totalMinutes % 60;
                    
                    // Snap to 15-minute intervals for better precision
                    let snappedHour = hour;
                    let snappedMinutes;
                    
                    if (minute < 7) {
                        snappedMinutes = 0;
                    } else if (minute < 22) {
                        snappedMinutes = 15;
                    } else if (minute < 37) {
                        snappedMinutes = 30;
                    } else if (minute < 52) {
                        snappedMinutes = 45;
                    } else {
                        snappedMinutes = 0;
                        snappedHour = hour + 1;
                    }
                    
                    // Ensure hour doesn't go beyond 23
                    if (snappedHour > 23) {
                        snappedHour = 23;
                        snappedMinutes = 45;
                    }
                    
                    const time = `${snappedHour.toString().padStart(2, '0')}:${snappedMinutes.toString().padStart(2, '0')}`;
                    
                    // Open the enhanced add form with pre-filled time
                    openEnhancedAddForm();
                    
                    // Pre-fill the time after the form opens
                    setTimeout(() => {
                        const timeEl = document.getElementById('enhancedEventTime');
                        if (timeEl) {
                            timeEl.value = time;
                        }
                    }, 300);
                }
            });
        }
        
        // Event drag functions for moving events around
        function startEventDrag(e) {
            e.dataTransfer.setData('text/plain', e.target.dataset.eventId);
            e.dataTransfer.effectAllowed = 'move';
            e.target.classList.add('dragging');
            
            // Remove dragging class after a short delay
            setTimeout(() => {
                e.target.classList.remove('dragging');
            }, 100);
        }
        
        // Handle dropping events to new time slots
        async function handleEventDrop(e) {
            e.preventDefault();
            e.target.classList.remove('drag-over');
            
            const eventId = e.dataTransfer.getData('text/plain');
            if (!eventId) return;
            
            // Calculate new time from drop position and snap to half-hour intervals
            const dayTimeline = document.getElementById('dayTimeline');
            const timelineEvents = dayTimeline.querySelector('.timeline-events');
            if (!timelineEvents) {
                console.error('Timeline events container not found');
                return;
            }
            
            const rect = timelineEvents.getBoundingClientRect();
            const y = e.clientY - rect.top;
            
            // Convert pixel position to time (1 pixel = 1 minute)
            const totalMinutes = Math.max(0, Math.round(y));
            const hour = Math.floor(totalMinutes / 60);
            const minute = totalMinutes % 60;
            
            // Snap to 15-minute intervals for better precision
            let snappedHour = hour;
            let snappedMinutes;
            
            if (minute < 7) {
                snappedMinutes = 0;
            } else if (minute < 22) {
                snappedMinutes = 15;
            } else if (minute < 37) {
                snappedMinutes = 30;
            } else if (minute < 52) {
                snappedMinutes = 45;
            } else {
                snappedMinutes = 0;
                snappedHour = hour + 1;
            }
            
            // Ensure hour doesn't go beyond 23
            if (snappedHour > 23) {
                snappedHour = 23;
                snappedMinutes = 45;
            }
            
            const newTime = `${snappedHour.toString().padStart(2, '0')}:${snappedMinutes.toString().padStart(2, '0')}`;
            console.log(`Moving event to ${newTime} (pixel: ${y}, totalMinutes: ${totalMinutes})`);
            
            // Update event time
            const event = allEvents.find(e => e.id == eventId);
            if (event) {
                event.start_time = newTime;
                await updateEvent(eventId, { start_time: newTime });
                await updateDayViewDisplay(false);
                showNotification('Event moved to ' + newTime);
            }
        }
        
        // Task completion functionality
        function toggleTaskCompletion(taskId) {
            const task = allTasks.find(t => t.id === taskId);
            if (task) {
                task.completed = !task.completed;
                task.completed_at = task.completed ? new Date().toISOString() : null;
                
                // Update task via API
                updateTask(task);
                
                // Refresh displays
                displayTasks();
                updateDayView();
            }
        }
        
        // Move incomplete tasks back to available list
        function moveTaskToAvailable(taskId) {
            const task = allTasks.find(t => t.id === taskId);
            if (task) {
                task.completed = false;
                task.completed_at = null;
                
                // Update task via API
                updateTask(task);
                
                // Refresh displays
                displayTasks();
                updateDayView();
            }
        }
        
        // Open event edit form using the same popup as + button
        function openEventEditForm(eventId) {
            const event = allEvents.find(e => e.id === eventId);
            if (event) {
                // Open the enhanced add form in edit mode
                openEnhancedAddForm();
                
                // Populate the form with existing event data
                setTimeout(() => {
                    const titleEl = document.getElementById('enhancedEventTitle');
                    const descriptionEl = document.getElementById('enhancedEventDescription');
                    const categoryEl = document.getElementById('enhancedEventCategory');
                    const timeEl = document.getElementById('enhancedEventTime');
                    const durationEl = document.getElementById('enhancedEventDuration');
                    const allDayEl = document.getElementById('enhancedAllDay');
                    
                    if (titleEl) titleEl.value = event.title || '';
                    if (descriptionEl) descriptionEl.value = event.description || '';
                    if (categoryEl) categoryEl.value = event.category || 'personal';
                    if (timeEl) timeEl.value = event.start_time || '';
                    if (durationEl) durationEl.value = event.duration || 30;
                    if (allDayEl) allDayEl.checked = event.all_day || false;
                    
                    // Update the form title to indicate editing
                    const formTitle = document.querySelector('.enhanced-form h3');
                    if (formTitle) {
                        formTitle.textContent = 'Edit Event';
                    }
                    
                    // Update the save button text
                    const saveBtn = document.getElementById('enhancedEventSaveBtn');
                    if (saveBtn) {
                        saveBtn.textContent = 'Update Event';
                    }
                    
                    // Store the event ID for updating
                    window.editingEventId = eventId;
                }, 100);
            }
        }

        let draggedTask = null;
        let touchStartY = 0;
        let touchStartX = 0;
        let isDragging = false;

        function handleDragStart(e) {
            draggedTask = {
                id: e.target.dataset.taskId,
                text: e.target.dataset.taskText,
                priority: e.target.dataset.taskPriority
            };
            e.target.classList.add('dragging');
        }

        function handleDragEnd(e) {
            e.target.classList.remove('dragging');
            draggedTask = null;
            isDragging = false;
        }

        // Touch event handlers for mobile
        function handleTouchStart(e) {
            const task = e.target.closest('.task-item');
            if (task) {
                const touch = e.touches[0];
                touchStartY = touch.clientY;
                touchStartX = touch.clientX;
                isDragging = false;
                
                // Store the task element for later use
                task._touchTask = task;
            }
        }

        function handleTouchMove(e) {
            const task = e.target.closest('.task-item') || e.target._touchTask;
            if (!task) return;
            
            if (!isDragging) {
                const touch = e.touches[0];
                const deltaY = Math.abs(touch.clientY - touchStartY);
                const deltaX = Math.abs(touch.clientX - touchStartX);
                
                // Start dragging if moved more than 10px
                if (deltaY > 10 || deltaX > 10) {
                    isDragging = true;
                    draggedTask = {
                        id: task.dataset.taskId,
                        text: task.dataset.taskText,
                        priority: task.dataset.taskPriority
                    };
                    task.classList.add('dragging');
                    e.preventDefault();
                }
            } else {
                e.preventDefault(); // Prevent scrolling while dragging
            }
        }

        function handleTouchEnd(e) {
            const task = e.target.closest('.task-item') || e.target._touchTask;
            if (task && isDragging) {
                task.classList.remove('dragging');
                
                // Find drop target
                const touch = e.changedTouches[0];
                const elementBelow = document.elementFromPoint(touch.clientX, touch.clientY);
                const timeSlot = elementBelow ? elementBelow.closest('.time-slot') : null;
                
                if (timeSlot && draggedTask) {
                    handleDrop({ target: timeSlot, preventDefault: () => {} });
                }
            }
            
            // Reset dragging state after a short delay to prevent click events
            setTimeout(() => {
                isDragging = false;
                draggedTask = null;
                if (task) {
                    task._touchTask = null;
                }
            }, 100);
        }

        function handleDragOver(e) {
            e.preventDefault();
            
            // Update drop zone indicator position
            const timelineEvents = e.target.closest('.timeline-events');
            if (timelineEvents && timelineEvents.classList.contains('drag-over')) {
                showDropZoneIndicator(e, timelineEvents);
            }
        }

        function handleDragEnter(e) {
            const timelineEvents = e.target.closest('.timeline-events');
            if (timelineEvents) {
                timelineEvents.classList.add('drag-over');
                showDropZoneIndicator(e, timelineEvents);
            }
        }

        function handleDragLeave(e) {
            const timelineEvents = e.target.closest('.timeline-events');
            if (timelineEvents) {
                timelineEvents.classList.remove('drag-over');
                hideDropZoneIndicator(timelineEvents);
            }
        }
        
        function showDropZoneIndicator(e, timelineEvents) {
            const rect = timelineEvents.getBoundingClientRect();
            const y = e.clientY - rect.top;
            
            // Remove existing indicator
            hideDropZoneIndicator(timelineEvents);
            
            // Create new indicator
            const indicator = document.createElement('div');
            indicator.className = 'drop-zone-indicator';
            indicator.style.top = `${y}px`;
            timelineEvents.appendChild(indicator);
        }
        
        function hideDropZoneIndicator(timelineEvents) {
            const existingIndicator = timelineEvents.querySelector('.drop-zone-indicator');
            if (existingIndicator) {
                existingIndicator.remove();
            }
        }

        async function handleDrop(e) {
            e.preventDefault();
            
            // Clean up drag indicators
            const timelineEvents = e.target.closest('.timeline-events');
            if (timelineEvents) {
                timelineEvents.classList.remove('drag-over');
                hideDropZoneIndicator(timelineEvents);
            }
            
            if (!draggedTask) return;
            
            // Calculate time from drop position and snap to half-hour intervals
            const dayTimeline = document.getElementById('dayTimeline');
            const eventsContainer = dayTimeline.querySelector('.timeline-events');
            if (!eventsContainer) {
                console.error('Timeline events container not found');
                return;
            }
            
            const rect = eventsContainer.getBoundingClientRect();
            const y = e.clientY - rect.top;
            
            // Convert pixel position to time (1 pixel = 1 minute)
            const totalMinutes = Math.max(0, Math.round(y));
            const hour = Math.floor(totalMinutes / 60);
            const minute = totalMinutes % 60;
            
            // Snap to 15-minute intervals for better precision
            let snappedHour = hour;
            let snappedMinutes;
            
            if (minute < 7) {
                snappedMinutes = 0;
            } else if (minute < 22) {
                snappedMinutes = 15;
            } else if (minute < 37) {
                snappedMinutes = 30;
            } else if (minute < 52) {
                snappedMinutes = 45;
            } else {
                snappedMinutes = 0;
                snappedHour = hour + 1;
            }
            
            // Ensure hour doesn't go beyond 23
            if (snappedHour > 23) {
                snappedHour = 23;
                snappedMinutes = 45;
            }
            
            const time = `${snappedHour.toString().padStart(2, '0')}:${snappedMinutes.toString().padStart(2, '0')}`;
            console.log(`Dropping task at ${time} (pixel: ${y}, totalMinutes: ${totalMinutes})`);
            
            if (!time) {
                showNotification('Invalid drop target', 'error');
                return;
            }
            
            // Remove from tasks list
            const taskElement = document.querySelector(`[data-task-id="${draggedTask.id}"]`);
            if (taskElement) {
                taskElement.remove();
            }
            
            // Create calendar event from task
            try {
                await createEventFromTask(draggedTask, time);
                showNotification(`Task scheduled for ${formatTime(time)}`);
                
                // Refresh the day view to show the new event (no forced reload)
                await updateDayViewDisplay(false);
            } catch (error) {
                console.error('Error creating event from task:', error);
                showNotification('Failed to schedule task', 'error');
                
                // Restore task to list if creation failed
                if (taskElement && taskElement.parentNode) {
                    taskElement.parentNode.appendChild(taskElement);
                }
            }
        }

        function removeScheduledTask(button) {
            const taskElement = button.closest('.scheduled-task');
            taskElement.remove();
        }

        async function createEventFromTask(task, time) {
            const dateStr = formatDate(currentDayView);
            const eventData = {
                title: task.text,
                start_date: dateStr,
                start_time: time,
                duration: 30, // Default 30 minutes
                category: 'task',
                description: `Scheduled from task list`
            };
            
            try {
                const newEvent = await saveEvent(eventData);
                allEvents.push(newEvent);
                showNotification('Task converted to calendar event');
                
                // Event is already saved via saveEvent, no need for ensurePersistence
            } catch (error) {
                showNotification('Failed to create event from task', 'error');
            }
        }

        // Load events from API
        async function loadEvents(forceRefresh = false) {
            try {
                const cacheKey = 'events';
                let events = null;
                
                if (!forceRefresh) {
                    events = getCachedData(eventCache, cacheKey);
                }
                
                if (!events) {
                    const response = await apiGetCached('/calendar/events', 60000);
                    events = Array.isArray(response) ? response : response.events || [];
                    setCachedData(eventCache, cacheKey, events);
                }
                
                allEvents = events;
                updateCalendar();
                if (selectedDate) {
                    updateDayView(selectedDate);
                }
                // Update API status to online
                document.getElementById('apiStatus').textContent = 'Online';
                document.getElementById('apiStatus').className = 'api-indicator online';
            } catch (error) {
                // Ensure overlay is hidden if any
                showGlobalLoading(false);
                handleError(error, 'loading events');
                // Keep demo data if API fails
                allEvents = [
                    {
                        id: 1,
                        title: 'Team Standup Meeting',
                        start_date: formatDate(new Date()),
                        start_time: '09:00',
                        category: 'work'
                    },
                    {
                        id: 2,
                        title: 'Dentist Appointment',
                        start_date: formatDate(new Date()),
                        start_time: '14:30',
                        category: 'health'
                    },
                    {
                        id: 3,
                        title: 'Dinner with Sarah',
                        start_date: formatDate(new Date()),
                        start_time: '18:00',
                        category: 'social'
                    }
                ];
                updateCalendar();
                if (selectedDate) {
                    updateDayView(selectedDate);
                }
            }
        }

        // Load reminders for a specific date
        async function loadReminders(date) {
            try {
                const response = await apiRequest('/reminders/');
                const reminders = response.reminders || [];
                
                // Filter reminders for the selected date
                const dateReminders = reminders.filter(reminder => 
                    reminder.due_date === date || !reminder.due_date
                );
                
                // Store reminders globally for time slot integration
                window.currentDayReminders = dateReminders;
                
                // Filter out time-based reminders for the list display (non-time reminders only)
                const nonTimeReminders = dateReminders.filter(reminder => !reminder.due_time);
                displayReminders(nonTimeReminders);
                
                // Regenerate time slots to include time-based reminders
                if (currentView === 'day') {
                    generateTimeSlots();
                }
            } catch (error) {
                console.error('Failed to load reminders:', error);
                window.currentDayReminders = [];
                displayReminders([]);
            }
        }

        // Get priority symbol for display
        function getPrioritySymbol(priority) {
            const symbols = {
                'critical': ' ',
                'high': ' ',
                'medium': ' ',
                'low': ' '
            };
            return symbols[priority] || symbols['medium'];
        }

        // Display reminders in the UI
        function displayReminders(reminders) {
            const remindersList = document.getElementById('remindersList');
            const remindersSection = document.getElementById('remindersSection');
            
            if (reminders.length === 0) {
                remindersList.innerHTML = '<div class="no-reminders">No reminders for this date</div>';
                remindersSection.style.display = 'none';
                return;
            }
            
            remindersSection.style.display = 'block';
            remindersList.innerHTML = reminders.map((reminder, index) => {
                // Assign different categories for variety if not specified
                const categories = ['personal', 'work', 'health', 'social', 'family', 'task'];
                const category = reminder.category || categories[index % categories.length];
                
                return `
                    <div class="reminder-item category-${category}" onclick="showReminderDetails(${reminder.id})">
                        <div class="reminder-title">${reminder.title}${getPrioritySymbol(reminder.priority)}</div>
                    </div>
                `;
            }).join('');
        }

        // Show add reminder form
        function showAddReminderForm() {
            openEnhancedAddForm();
            // Switch to reminder mode
            toggleAddType('reminder');
        }

        // Event reminders management
        let eventReminders = [];
        let eventLinks = [];

        function addReminderToEvent() {
            const reminderTime = prompt('Enter reminder time (e.g., "2 hours before", "30 minutes before", "1 day before"):');
            if (!reminderTime) return;
            
            const reminderPriority = prompt('Enter priority (low, medium, high, critical):', 'medium');
            if (!reminderPriority) return;
            
            const reminder = {
                id: Date.now(),
                time: reminderTime,
                priority: reminderPriority,
                type: 'before'
            };
            
            eventReminders.push(reminder);
            updateEventRemindersList();
        }

        function removeReminderFromEvent(reminderId) {
            eventReminders = eventReminders.filter(r => r.id !== reminderId);
            updateEventRemindersList();
        }

        function updateEventRemindersList() {
            const remindersList = document.getElementById('eventRemindersList');
            
            if (eventReminders.length === 0) {
                remindersList.innerHTML = '<div class="no-reminders">No reminders added yet</div>';
                return;
            }
            
            remindersList.innerHTML = eventReminders.map(reminder => `
                <div class="event-reminder-item">
                    <div class="event-reminder-details">
                        <div class="event-reminder-time">${reminder.time}</div>
                        <span class="event-reminder-priority priority-${reminder.priority}">${reminder.priority}</span>
                    </div>
                    <button class="remove-reminder-btn" onclick="removeReminderFromEvent(${reminder.id})"></button>
                </div>
            `).join('');
        }

        // Cross-linking management
        function showLinkItemModal() {
            document.getElementById('linkItemModal').classList.add('active');
        }

        function closeLinkItemModal() {
            document.getElementById('linkItemModal').classList.remove('active');
            // Clear form
            document.getElementById('linkItemText').value = '';
            document.getElementById('linkListType').value = 'shopping';
            document.getElementById('linkWhenToAdd').value = '1_week_before';
            document.getElementById('linkItemPriority').value = 'medium';
        }

        function addLinkToEvent() {
            const listType = document.getElementById('linkListType').value;
            const itemText = document.getElementById('linkItemText').value.trim();
            const whenToAdd = document.getElementById('linkWhenToAdd').value;
            const priority = document.getElementById('linkItemPriority').value;
            
            if (!itemText) {
                alert('Please enter item text');
                return;
            }
            
            const link = {
                id: Date.now(),
                listType: listType,
                itemText: itemText,
                whenToAdd: whenToAdd,
                priority: priority
            };
            
            eventLinks.push(link);
            updateEventLinksList();
            closeLinkItemModal();
        }

        function removeLinkFromEvent(linkId) {
            eventLinks = eventLinks.filter(l => l.id !== linkId);
            updateEventLinksList();
        }

        function updateEventLinksList() {
            const linksList = document.getElementById('eventLinksList');
            
            if (eventLinks.length === 0) {
                linksList.innerHTML = '<div class="no-links">No items linked yet</div>';
                return;
            }
            
            const listTypeNames = {
                'shopping': ' Shopping',
                'personal_todos': ' Personal Todos',
                'work_todos': ' Work Todos',
                'bucket': ' Bucket List'
            };
            
            const whenNames = {
                'immediately': 'Immediately',
                '1_week_before': '1 week before',
                '2_weeks_before': '2 weeks before',
                '3_days_before': '3 days before',
                '1_day_before': '1 day before'
            };
            
            linksList.innerHTML = eventLinks.map(link => `
                <div class="event-link-item">
                    <div class="event-link-details">
                        <div class="event-link-text">${link.itemText}</div>
                        <div class="event-link-meta">
                            <span class="event-link-list">${listTypeNames[link.listType]}</span>
                            <span class="event-link-when">${whenNames[link.whenToAdd]}</span>
                            <span class="event-reminder-priority priority-${link.priority}">${link.priority}</span>
                        </div>
                    </div>
                    <button class="remove-reminder-btn" onclick="removeLinkFromEvent(${link.id})"></button>
                </div>
            `).join('');
        }

        // Show reminder details
        function showReminderDetails(reminderId) {
            // TODO: Implement reminder details view
            console.log('Show reminder details:', reminderId);
        }

        // Notifications system
        function openNotifications() {
            document.getElementById('notificationsPanel').classList.add('open');
            loadNotifications();
        }

        function closeNotifications() {
            document.getElementById('notificationsPanel').classList.remove('open');
        }

        async function loadNotifications() {
            try {
                const response = await apiRequest('/reminders/notifications/pending');
                const notifications = response.notifications || [];
                displayNotifications(notifications);
            } catch (error) {
                console.error('Failed to load notifications:', error);
                displayNotifications([]);
            }
        }

        function displayNotifications(notifications) {
            const notificationsContent = document.getElementById('notificationsContent');
            
            if (notifications.length === 0) {
                notificationsContent.innerHTML = '<div class="no-notifications">No notifications</div>';
                return;
            }
            
            notificationsContent.innerHTML = notifications.map(notification => `
                <div class="notification-item ${notification.is_delivered ? '' : 'unread'}" 
                     onclick="handleNotificationClick(${notification.id})">
                    <div class="notification-title">${notification.message}</div>
                    <div class="notification-meta">
                        <span class="notification-time">${formatNotificationTime(notification.notification_time)}</span>
                        <span class="notification-priority priority-${notification.priority}">${notification.priority}</span>
                    </div>
                </div>
            `).join('');
        }

        function formatNotificationTime(timeStr) {
            const date = new Date(timeStr);
            const now = new Date();
            const diff = now - date;
            const minutes = Math.floor(diff / 60000);
            const hours = Math.floor(minutes / 60);
            const days = Math.floor(hours / 24);
            
            if (minutes < 1) return 'Just now';
            if (minutes < 60) return `${minutes}m ago`;
            if (hours < 24) return `${hours}h ago`;
            return `${days}d ago`;
        }

        function handleNotificationClick(notificationId) {
            // Mark notification as acknowledged
            acknowledgeNotification(notificationId);
            closeNotifications();
        }

        async function acknowledgeNotification(notificationId) {
            try {
                await apiRequest(`/reminders/notifications/${notificationId}/acknowledge`, {
                    method: 'POST'
                });
                // Reload notifications
                loadNotifications();
            } catch (error) {
                console.error('Failed to acknowledge notification:', error);
            }
        }

        // Save event to API
        async function saveEvent(eventData) {
            try {
                const response = await apiRequest('/calendar/events', {
                    method: 'POST',
                    body: JSON.stringify(eventData)
                });
                // Invalidate event cache when new event is saved
                invalidateCache(eventCache, 'events');
                return response.event || response;
            } catch (error) {
                console.error('Failed to save event:', error);
                throw error;
            }
        }

        // Update event in API
        async function updateEvent(eventId, eventData) {
            try {
                const response = await apiRequest(`/calendar/events/${eventId}`, {
                    method: 'PUT',
                    body: JSON.stringify(eventData)
                });
                // Invalidate event cache when event is updated
                invalidateCache(eventCache, 'events');
                return response.event || response;
            } catch (error) {
                console.error('Failed to update event:', error);
                throw error;
            }
        }

        // Delete event from API
        async function deleteEventFromAPI(eventId) {
            try {
                await apiRequest(`/calendar/events/${eventId}`, {
                    method: 'DELETE'
                });
                // Invalidate event cache when event is deleted
                invalidateCache(eventCache, 'events');
            } catch (error) {
                console.error('Failed to delete event:', error);
                throw error;
            }
        }

        // Calendar settings functions
        async function loadCalendarSettings() {
            try {
                const response = await apiRequest('/settings/calendar');
                if (response && response.settings) {
                    calendarSettings = { ...calendarSettings, ...response.settings };
                }
            } catch (error) {
                console.log('Using default calendar settings');
            }
            
            // Apply settings
            if (calendarSettings.defaultView) {
                switchView(calendarSettings.defaultView);
            }
        }

        async function saveCalendarSettings() {
            try {
                await apiRequest('/settings/calendar', {
                    method: 'POST',
                    body: JSON.stringify({ settings: calendarSettings })
                });
                showNotification('Calendar settings saved');
            } catch (error) {
                console.error('Failed to save calendar settings:', error);
            }
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', async () => {
            selectedDate = formatDate(new Date());
            currentDayView = new Date();
            
            // Load settings first
            await loadCalendarSettings();
            
            // Set default filter button state
            document.getElementById('allTasksBtn').classList.add('active');
            
            loadEvents();
            loadTasksForDay();
            selectDate(selectedDate);
            updateAPIStatus();
            
            // Add event listener for recurring fields
            document.getElementById('enhancedEventRecurring').addEventListener('change', toggleRecurringFields);
            
            // Apply default view if set in settings
            if (calendarSettings.defaultView && calendarSettings.defaultView !== 'month') {
                switchView(calendarSettings.defaultView);
            }
            
            // Handle routed data from other pages
            handleRoutedData();
        });

        // Handle routed data from URL parameters
        function handleRoutedData() {
            const urlParams = new URLSearchParams(window.location.search);
            const action = urlParams.get('action');
            const data = urlParams.get('data');
            
            if (action && data) {
                try {
                    const formData = JSON.parse(decodeURIComponent(data));
                    
                    // Open the enhanced form
                    openEnhancedAddForm();
                    
                    // Populate based on action
                    if (action === 'addEvent') {
                        document.getElementById('enhancedEventTitle').value = formData.title;
                        if (formData.time) {
                            document.getElementById('enhancedEventTime').value = formData.time;
                        }
                        if (formData.date) {
                            document.getElementById('enhancedEventDate').value = formData.date;
                        }
                        document.getElementById('enhancedEventCategory').value = formData.category;
                    }
                    
                    // Clean up URL
                    window.history.replaceState({}, document.title, window.location.pathname);
                } catch (error) {
                    console.error('Error handling routed data:', error);
                }
            }
        }

        // Update API status
        async function updateAPIStatus() {
            try {
                const response = await fetch(`${API_BASE}/health`);
                const indicator = document.getElementById('apiStatus');
                if (response.ok) {
                    indicator.textContent = 'Online';
                    indicator.className = 'api-indicator online';
                } else {
                    indicator.textContent = 'Warning';
                    indicator.className = 'api-indicator warning';
                }
            } catch (error) {
                document.getElementById('apiStatus').textContent = 'Offline';
                document.getElementById('apiStatus').className = 'api-indicator offline';
            }
        }

        // Overlay Functions
        function openAddOptions() {
            document.getElementById('addOptionsOverlay').classList.add('active');
        }

        function closeAddOptions() {
            document.getElementById('addOptionsOverlay').classList.remove('active');
        }

        function openAIChat() {
            closeAddOptions();
            // Navigate to chat with context about adding calendar events
            window.location.href = 'index.html?context=calendar&action=add_event';
        }

        function openManualEventForm() {
            closeAddOptions();
            addEvent(); // Use existing manual form
        }

        function showTaskDetails(taskId) {
            const task = allTasks.find(t => t.id == taskId);
            if (!task) return;

            const overlay = document.getElementById('itemDetailsOverlay');
            const title = document.getElementById('itemDetailsTitle');
            const body = document.getElementById('itemDetailsBody');
            const actions = document.getElementById('itemDetailsActions');

            title.textContent = 'Task Details';
            
            body.innerHTML = `
                <div class="item-details-field">
                    <div class="item-details-label">Task</div>
                    <div class="item-details-value">${task.text}</div>
                </div>
                <div class="item-details-field">
                    <div class="item-details-label">Priority</div>
                    <div class="item-details-value">${task.priority}</div>
                </div>
                <div class="item-details-field">
                    <div class="item-details-label">Category</div>
                    <div class="item-details-value">${task.category === 'work' ? 'Work' : 'Personal'}</div>
                </div>
                <div class="item-details-field">
                    <div class="item-details-label">List</div>
                    <div class="item-details-value">${task.listName || 'Unknown'}</div>
                </div>
                <div class="item-details-field">
                    <div class="item-details-label">Status</div>
                    <div class="item-details-value">${task.completed ? 'Completed' : 'Pending'}</div>
                </div>
            `;

            actions.innerHTML = `
                <button class="item-details-btn edit" onclick="editTask(${task.id})">Edit</button>
                <button class="item-details-btn delete" onclick="deleteTask(${task.id})">Delete</button>
            `;

            overlay.classList.add('active');
        }

        function showEventDetails(eventId) {
            const event = allEvents.find(e => e.id == eventId);
            if (!event) return;

            const overlay = document.getElementById('itemDetailsOverlay');
            const title = document.getElementById('itemDetailsTitle');
            const body = document.getElementById('itemDetailsBody');
            const actions = document.getElementById('itemDetailsActions');

            title.textContent = 'Event Details';
            
            body.innerHTML = `
                <div class="item-details-field">
                    <div class="item-details-label">Title</div>
                    <div class="item-details-value">${event.title}</div>
                </div>
                <div class="item-details-field">
                    <div class="item-details-label">Date</div>
                    <div class="item-details-value">${event.start_date || event.date}</div>
                </div>
                ${event.start_time ? `
                <div class="item-details-field">
                    <div class="item-details-label">Time</div>
                    <div class="item-details-value">${formatTime(event.start_time)}</div>
                </div>
                ` : ''}
                <div class="item-details-field">
                    <div class="item-details-label">Category</div>
                    <div class="item-details-value">${event.category || 'personal'}</div>
                </div>
                ${event.description ? `
                <div class="item-details-field">
                    <div class="item-details-label">Description</div>
                    <div class="item-details-value">${event.description}</div>
                </div>
                ` : ''}
                <div class="item-details-field">
                    <div class="item-details-label">Type</div>
                    <div class="item-details-value">${event.all_day ? 'All Day Event' : 'Timed Event'}</div>
                </div>
            `;

            actions.innerHTML = `
                <button class="item-details-btn edit" onclick="editEvent(${event.id})">Edit</button>
                <button class="item-details-btn delete" onclick="deleteEvent(${event.id})">Delete</button>
            `;

            overlay.classList.add('active');
        }

        function closeItemDetails() {
            document.getElementById('itemDetailsOverlay').classList.remove('active');
        }

        async function editTask(taskId) {
            const task = allTasks.find(t => t.id == taskId);
            if (!task) return;

            const newText = prompt('Edit task:', task.text);
            if (newText !== null && newText.trim() !== '') {
                try {
                    // Determine the correct API endpoint based on task category
                    const listType = task.category === 'work' ? 'work_todos' : 'personal_todos';
                    
                    // Update task via API
                    await apiRequest(`/lists/${listType}/${taskId}`, {
                        method: 'PUT',
                        body: JSON.stringify({ text: newText.trim() })
                    });
                    
                    // Update local array
                    task.text = newText.trim();
                    displayTasks();
                    closeItemDetails();
                    showNotification('Task updated');
                } catch (error) {
                    showNotification('Failed to update task', 'error');
                }
            }
        }

        async function deleteTask(taskId) {
            if (confirm('Delete this task?')) {
                try {
                    const task = allTasks.find(t => t.id == taskId);
                    if (!task) return;
                    
                    // Determine the correct API endpoint based on task category
                    const listType = task.category === 'work' ? 'work_todos' : 'personal_todos';
                    
                    await apiRequest(`/lists/${listType}/${taskId}`, {
                        method: 'DELETE'
                    });
                    
                    allTasks = allTasks.filter(t => t.id !== taskId);
                    displayTasks();
                    closeItemDetails();
                    showNotification('Task deleted');
                } catch (error) {
                    showNotification('Failed to delete task', 'error');
                }
            }
        }


        function getEventDuration(event) {
            if (event.duration) {
                const hours = Math.floor(event.duration / 60);
                const minutes = event.duration % 60;
                if (hours > 0) {
                    return minutes > 0 ? `${hours}h ${minutes}m` : `${hours}h`;
                }
                return `${minutes}m`;
            }
            return '30m'; // Default duration
        }


        // Enhanced Add Form Functions
        function openEnhancedAddForm() {
            closeAddOptions();
            document.getElementById('enhancedAddOverlay').classList.add('active');
            
            // Reset form to create mode
            const formTitle = document.querySelector('.enhanced-form h3');
            if (formTitle) {
                formTitle.textContent = 'Add Event';
            }
            
            const saveBtn = document.getElementById('enhancedEventSaveBtn');
            if (saveBtn) {
                saveBtn.textContent = 'Create Event';
            }
            
            // Clear editing state
            window.editingEventId = null;
            
            // Set default values
            const today = new Date();
            document.getElementById('enhancedEventDate').value = formatDate(today);
            document.getElementById('enhancedEventTime').value = '09:00';
            document.getElementById('enhancedEventTitle').focus();
        }

        function closeEnhancedAddForm() {
            document.getElementById('enhancedAddOverlay').classList.remove('active');
            
            // Reset form to create mode
            const formTitle = document.querySelector('.enhanced-form h3');
            if (formTitle) {
                formTitle.textContent = 'Add Event';
            }
            
            const saveBtn = document.getElementById('enhancedEventSaveBtn');
            if (saveBtn) {
                saveBtn.textContent = 'Create Event';
            }
            
            // Clear editing state
            window.editingEventId = null;
        }

        // Toggle between Event and Task forms
        function toggleAddType(type) {
            const eventForm = document.querySelector('.enhanced-form-section');
            const toggleEvent = document.getElementById('toggleEvent');
            const toggleReminder = document.getElementById('toggleReminder');
            const title = document.querySelector('.enhanced-add-title');
            const formTitle = document.getElementById('formTitle');
            const reminderFields = document.getElementById('reminderFields');
            const eventRemindersSection = document.getElementById('eventRemindersSection');
            
            if (type === 'event') {
                toggleEvent.classList.add('active');
                toggleReminder.classList.remove('active');
                title.textContent = 'Add Event';
                formTitle.textContent = ' Event Details';
                // Show event-specific fields
                reminderFields.style.display = 'none';
                eventRemindersSection.style.display = 'block';
            } else if (type === 'reminder') {
                toggleEvent.classList.remove('active');
                toggleReminder.classList.add('active');
                title.textContent = 'Add Reminder';
                formTitle.textContent = ' Reminder Details';
                // Show reminder-specific fields
                reminderFields.style.display = 'block';
                eventRemindersSection.style.display = 'none';
            }
        }

        function toggleAllDay() {
            const allDayCheckbox = document.getElementById('enhancedAllDay');
            const timeInput = document.getElementById('enhancedEventTime');
            const durationSelect = document.getElementById('enhancedEventDuration');
            
            if (allDayCheckbox.checked) {
                timeInput.style.display = 'none';
                durationSelect.value = '480'; // 8 hours
            } else {
                timeInput.style.display = 'block';
                durationSelect.value = '30'; // 30 minutes
            }
        }

        function toggleRecurringFields() {
            const recurringSelect = document.getElementById('enhancedEventRecurring');
            const intervalField = document.getElementById('recurringIntervalField');
            const endField = document.getElementById('recurringEndField');
            
            if (recurringSelect.value) {
                intervalField.style.display = 'block';
                endField.style.display = 'block';
            } else {
                intervalField.style.display = 'none';
                endField.style.display = 'none';
            }
        }

        // Voice Dictation Functions
        let recognition = null;
        let isListening = false;
        let currentTranscript = '';

        function initVoiceRecognition() {
            if ('webkitSpeechRecognition' in window) {
                recognition = new webkitSpeechRecognition();
            } else if ('SpeechRecognition' in window) {
                recognition = new SpeechRecognition();
            } else {
                console.log('Speech recognition not supported');
                return false;
            }

            recognition.continuous = false;
            recognition.interimResults = true;
            recognition.lang = 'en-US';

            recognition.onstart = function() {
                isListening = true;
                showConversation();
                showUserMessage('Listening...');
            };

            recognition.onresult = function(event) {
                let interimTranscript = '';
                for (let i = event.resultIndex; i < event.results.length; i++) {
                    if (event.results[i].isFinal) {
                        currentTranscript += event.results[i][0].transcript;
                    } else {
                        interimTranscript += event.results[i][0].transcript;
                    }
                }
                if (interimTranscript) {
                    showUserMessage(interimTranscript);
                }
            };

            recognition.onerror = function(event) {
                console.error('Speech recognition error:', event.error);
                isListening = false;
                
                let errorMessage = 'Sorry, I had trouble hearing you. ';
                switch(event.error) {
                    case 'not-allowed':
                        errorMessage = 'Microphone access denied. Please allow microphone access and try again.';
                        break;
                    case 'no-speech':
                        errorMessage = 'I didn\'t hear anything. Please try again.';
                        break;
                    case 'audio-capture':
                        errorMessage = 'No microphone found. Please check your microphone.';
                        break;
                    case 'network':
                        errorMessage = 'Network error. Please check your connection.';
                        break;
                    default:
                        errorMessage = 'Something went wrong. Please try again.';
                }
                
                showAssistantMessage(errorMessage);
                
                // Show grant permission button for not-allowed errors
                if (event.error === 'not-allowed') {
                    const grantBtn = document.getElementById('grantPermissionBtn');
                    if (grantBtn) grantBtn.style.display = 'inline-block';
                }
                
                // Reset button
                const startBtn = document.getElementById('startListeningBtn');
                if (startBtn) {
                    startBtn.textContent = 'Start Listening';
                    startBtn.onclick = startListening;
                }
            };

            recognition.onend = function() {
                isListening = false;
                if (currentTranscript.trim()) {
                    processVoiceCommand(currentTranscript);
                } else {
                    showAssistantMessage('I didn\'t hear anything. Please try again.');
                }
                
                // Reset button
                const startBtn = document.getElementById('startListeningBtn');
                if (startBtn) {
                    startBtn.textContent = 'Start Listening';
                    startBtn.onclick = startListening;
                }
            };

            return true;
        }

        async function startVoiceInput() {
            console.log(' Voice input started');
            
            // Check if getUserMedia is available
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                showAssistantMessage('Voice input is not available. Please use HTTPS or a modern browser.');
                return;
            }
            
            // Request microphone permission
            try {
                console.log(' Requesting microphone permission...');
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                console.log(' Permission granted!');
                
                // Permission granted, stop the stream
                stream.getTracks().forEach(track => track.stop());
                
                // Initialize speech recognition
                if (!initVoiceRecognition()) {
                    showAssistantMessage('Speech recognition is not supported in this browser.');
                    return;
                }
                
                currentTranscript = '';
                recognition.start();
                
            } catch (error) {
                console.error(' Microphone permission denied:', error);
                showAssistantMessage('Microphone access denied. Please allow microphone access and try again.');
            }
        }

        function toggleVoiceInput() {
            if (isListening) {
                stopVoiceInput();
            } else {
                startVoiceInput();
            }
        }

        function stopVoiceInput() {
            if (recognition && isListening) {
                recognition.stop();
            }
            isListening = false;
            currentTranscript = '';
        }

        // Route to other pages with data
        function routeToPage(page, action, formData) {
            if (page === 'lists') {
                window.location.href = `lists.html?action=${action}&data=${encodeURIComponent(JSON.stringify(formData))}`;
            } else if (page === 'journal') {
                window.location.href = `journal.html?action=${action}&data=${encodeURIComponent(JSON.stringify(formData))}`;
            } else {
                showAssistantMessage(`I understand you want to add something to ${page}, but I'm not sure how to handle that from here.`);
            }
        }

        async function startListening() {
            if (!recognition) return;
            
            // Request microphone permission first
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                // Permission granted, stop the stream and start recognition
                stream.getTracks().forEach(track => track.stop());
                
                currentTranscript = '';
                recognition.start();
                document.getElementById('startListeningBtn').textContent = 'Stop Listening';
                document.getElementById('startListeningBtn').onclick = stopListening;
                
                // Hide grant permission button if it was shown
                const grantBtn = document.getElementById('grantPermissionBtn');
                if (grantBtn) grantBtn.style.display = 'none';
            } catch (error) {
                console.error('Microphone permission denied:', error);
                updateVoiceStatus('error', ' Permission Denied', 'Microphone access is required for voice input.');
                
                // Show grant permission button
                const grantBtn = document.getElementById('grantPermissionBtn');
                if (grantBtn) grantBtn.style.display = 'inline-block';
            }
        }

        async function requestMicrophonePermission() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                stream.getTracks().forEach(track => track.stop());
                
                updateVoiceStatus('idle', ' Ready', 'Permission granted! Click "Start Listening" to begin.');
                
                // Hide grant permission button
                const grantBtn = document.getElementById('grantPermissionBtn');
                if (grantBtn) grantBtn.style.display = 'none';
            } catch (error) {
                console.error('Microphone permission still denied:', error);
                updateVoiceStatus('error', ' Still Denied', 'Please check your browser settings and allow microphone access for this site.');
            }
        }

        function updateVoiceStatus(status, icon, text) {
            const statusEl = document.getElementById('voiceStatus');
            const textEl = document.getElementById('voiceText');
            const iconEl = document.querySelector('.voice-icon');
            
            if (statusEl) {
                statusEl.className = `voice-status ${status}`;
            }
            if (textEl) {
                textEl.textContent = text;
            }
            if (iconEl) {
                iconEl.textContent = icon;
            }
        }

        // Voice conversation functions
        function showUserMessage(text) {
            const userMessage = document.getElementById('userMessage');
            const userText = document.getElementById('userText');
            if (userMessage && userText) {
                userText.textContent = text;
                userMessage.style.display = 'block';
            }
        }

        function showAssistantMessage(text) {
            const assistantMessage = document.getElementById('assistantMessage');
            const assistantText = document.getElementById('assistantText');
            if (assistantMessage && assistantText) {
                assistantText.textContent = text;
                assistantMessage.style.display = 'block';
            }
        }

        function showConversation() {
            const conversation = document.getElementById('voiceConversation');
            if (conversation) {
                conversation.style.display = 'block';
            }
        }

        // AI-powered command processing for calendar
        function processWithAI(command) {
            const patterns = {
                // Event creation patterns
                createEvent: /(?:create|add|new|schedule|book)\s+(?:a\s+)?(?:meeting|appointment|event|reminder)\s+(?:called|named|for)?\s*(.+)/i,
                // Time patterns
                time: {
                    specific: /(\d{1,2}):(\d{2})\s*(am|pm)?/gi,
                    hour: /(\d{1,2})\s*(am|pm)/gi,
                    relative: /(morning|afternoon|evening|night|tomorrow|today|next\s+week)/gi
                },
                // Date patterns
                date: {
                    today: /today/gi,
                    tomorrow: /tomorrow/gi,
                    weekday: /(monday|tuesday|wednesday|thursday|friday|saturday|sunday)/gi
                },
                // Category detection
                category: {
                    work: /(?:work|job|office|meeting|project|task|deadline|business|conference)/i,
                    health: /(?:doctor|health|medical|appointment|checkup|dentist|hospital)/i,
                    social: /(?:party|birthday|celebration|dinner|lunch|social|friends)/i,
                    family: /(?:family|kids|children|parent|school|home)/i
                }
            };

            let result = {
                action: 'addEvent',
                title: '',
                time: '',
                date: '',
                category: 'personal',
                confidence: 0
            };

            // Extract title
            const eventMatch = command.match(patterns.createEvent);
            if (eventMatch) {
                result.title = eventMatch[1].trim();
                result.confidence = 0.9;
            } else {
                result.title = command;
                result.confidence = 0.6;
            }

            // Extract time
            const timeMatch = command.match(patterns.time.specific) || command.match(patterns.time.hour);
            if (timeMatch) {
                result.time = timeMatch[0];
            } else if (patterns.time.relative.test(command)) {
                if (command.includes('morning')) result.time = '09:00';
                else if (command.includes('afternoon')) result.time = '14:00';
                else if (command.includes('evening') || command.includes('night')) result.time = '19:00';
            }

            // Extract date
            if (patterns.date.today.test(command)) {
                result.date = new Date().toISOString().split('T')[0];
            } else if (patterns.date.tomorrow.test(command)) {
                const tomorrow = new Date();
                tomorrow.setDate(tomorrow.getDate() + 1);
                result.date = tomorrow.toISOString().split('T')[0];
            }

            // Determine category
            if (patterns.category.work.test(command)) result.category = 'work';
            else if (patterns.category.health.test(command)) result.category = 'health';
            else if (patterns.category.social.test(command)) result.category = 'social';
            else if (patterns.category.family.test(command)) result.category = 'family';

            return result;
        }

        function updateVoiceText(text) {
            const transcriptEl = document.getElementById('voiceTranscript');
            if (transcriptEl) {
                transcriptEl.textContent = text;
            }
        }

        function processVoiceCommand(transcript) {
            showAssistantMessage('Processing...');
            showUserMessage(transcript);
            
            // Use unified AI processing
            const result = window.zoeAI.processInput(transcript, { page: 'calendar' });
            
            // Show the AI's response
            if (result.response) {
                showAssistantMessage(result.response);
            }
            
            if (result.routing.page === 'calendar') {
                // Populate form fields with AI results
                document.getElementById('enhancedEventTitle').value = result.routing.formData.title;
                if (result.routing.formData.time) {
                    document.getElementById('enhancedEventTime').value = result.routing.formData.time;
                }
                if (result.routing.formData.date) {
                    document.getElementById('enhancedEventDate').value = result.routing.formData.date;
                }
                document.getElementById('enhancedEventCategory').value = result.routing.formData.category;
                document.getElementById('enhancedEventDuration').value = '30'; // Default duration
            } else if (result.routing.page === 'conversation') {
                // Handle conversational responses
                if (result.intent === 'greeting' || result.intent === 'question') {
                    // Just show the response, no form population needed
                }
            } else if (result.routing.page === 'memory') {
                // Memory saved, just show confirmation
            } else {
                // Route to other pages
                routeToPage(result.routing.page, result.routing.action, result.routing.formData);
            }
            
            // Hide voice controls after success
            setTimeout(() => {
                stopVoiceInput();
            }, 2000);
        }

        async function saveEnhancedEvent() {
            const title = document.getElementById('enhancedEventTitle').value.trim();
            const date = document.getElementById('enhancedEventDate').value;
            const time = document.getElementById('enhancedEventTime').value;
            const duration = parseInt(document.getElementById('enhancedEventDuration').value);
            const category = document.getElementById('enhancedEventCategory').value;
            const description = document.getElementById('enhancedEventDescription').value.trim();
            const allDay = document.getElementById('enhancedAllDay').checked;
            
            // Check if we're editing an existing event
            const isEditing = window.editingEventId;
            
            // Check if we're in reminder mode
            const isReminderMode = document.getElementById('toggleReminder').classList.contains('active');
            
            // Validate event data
            const eventData = {
                title: title,
                start_date: date,
                start_time: allDay ? null : time,
                all_day: allDay,
                duration: duration,
                category: category,
                description: description
            };
            
            const validationErrors = validateEventData(eventData);
            if (!showValidationErrors(validationErrors)) {
                return;
            }
            
            if (isReminderMode) {
                // Save as reminder
                const priority = document.getElementById('enhancedReminderPriority').value;
                const reminderType = document.getElementById('enhancedReminderType').value;
                const requiresAck = document.getElementById('enhancedRequiresAck').checked;
                
                const reminderData = {
                    title: title,
                    description: description,
                    reminder_type: reminderType,
                    category: category,
                    priority: priority,
                    due_date: date,
                    due_time: allDay ? null : time,
                    requires_acknowledgment: requiresAck
                };
                
                try {
                    const response = await apiRequest('/reminders/', {
                        method: 'POST',
                        body: JSON.stringify(reminderData)
                    });
                    
                    // Reload reminders for the current date
                    if (selectedDate) {
                        loadReminders(selectedDate);
                    }
                    
                    closeEnhancedAddForm();
                    showNotification('Reminder created successfully');
                } catch (error) {
                    showNotification('Failed to create reminder', 'error');
                }
            } else {
                // Save as event
            if (!allDay && !time) {
                alert('Please enter a start time or check all-day event');
                return;
            }
            
            // Get recurring data
            const recurringPattern = document.getElementById('enhancedEventRecurring').value;
            const recurringInterval = document.getElementById('enhancedEventRecurringInterval').value;
            const recurringEnd = document.getElementById('enhancedEventRecurringEnd').value;
            
            let recurringData = null;
            if (recurringPattern) {
                recurringData = {
                    pattern: recurringPattern,
                    interval: parseInt(recurringInterval)
                };
                if (recurringEnd) {
                    recurringData.end_date = recurringEnd;
                }
            }
            
            const eventData = {
                title: title,
                start_date: date,
                start_time: allDay ? null : time,
                duration: allDay ? 480 : duration, // 8 hours for all-day
                all_day: allDay,
                category: category,
                description: description,
                recurring: recurringData ? JSON.stringify(recurringData) : null
            };
            
            try {
                if (isEditing) {
                    // Update existing event
                    const updatedEvent = await updateEvent(window.editingEventId, eventData);
                    const eventIndex = allEvents.findIndex(e => e.id === window.editingEventId);
                    if (eventIndex !== -1) {
                        allEvents[eventIndex] = updatedEvent;
                    }
                    showNotification('Event updated successfully');
                    window.editingEventId = null; // Clear editing state
                } else {
                    // Create new event
                    const newEvent = await saveEvent(eventData);
                    allEvents.push(newEvent);
                        
                    // Create reminders for the event if any were added
                    if (eventReminders.length > 0) {
                        await createEventReminders(newEvent.id, eventReminders);
                    }
                    
                    // Create cross-links for the event if any were added
                    if (eventLinks.length > 0) {
                        await createEventLinks(newEvent.id, eventLinks, newEvent.start_date);
                    }
                    
                    // Handle AI-generated cross-links
                    if (formData.crossLinks && formData.crossLinks.length > 0) {
                        await createEventLinks(newEvent.id, formData.crossLinks, newEvent.start_date);
                    }
                    showNotification('Event created successfully');
                }
                
                updateCalendar();
                if (currentView === 'day') {
                    await updateDayViewDisplay(false);
                }
                closeEnhancedAddForm();
            } catch (error) {
                showNotification(isEditing ? 'Failed to update event' : 'Failed to create event', 'error');
            }
            }
        }

        // Create reminders for an event
        async function createEventReminders(eventId, reminders) {
            for (const reminder of reminders) {
                try {
                    const reminderData = {
                        title: `Reminder: ${reminder.time}`,
                        description: `Reminder for event`,
                        reminder_type: 'once',
                        category: 'personal',
                        priority: reminder.priority,
                        linked_list_id: eventId
                    };
                    
                    await apiRequest('/reminders/', {
                        method: 'POST',
                        body: JSON.stringify(reminderData)
                    });
                } catch (error) {
                    console.error('Failed to create event reminder:', error);
                }
            }
        }

        // Create cross-links for an event
        async function createEventLinks(eventId, links, eventDate) {
            for (const link of links) {
                try {
                    // Calculate when to add the item based on the event date
                    const addDate = calculateAddDate(eventDate, link.whenToAdd);
                    
                    if (link.whenToAdd === 'immediately') {
                        // Add immediately to the list
                        await addItemToList(link.listType, link.itemText, link.priority);
                    } else {
                        // Create a reminder to add the item at the calculated date
                        const reminderData = {
                            title: `Add to ${getListTypeName(link.listType)}: ${link.itemText}`,
                            description: `Auto-generated reminder to add item to list`,
                            reminder_type: 'once',
                            category: 'personal',
                            priority: link.priority,
                            due_date: addDate,
                            due_time: '09:00:00', // Default morning time
                            linked_list_id: eventId
                        };
                        
                        await apiRequest('/reminders/', {
                            method: 'POST',
                            body: JSON.stringify(reminderData)
                        });
                    }
                } catch (error) {
                    console.error('Failed to create event link:', error);
                }
            }
        }

        // Calculate when to add an item based on event date
        function calculateAddDate(eventDate, whenToAdd) {
            const event = new Date(eventDate);
            const addDate = new Date(event);
            
            switch (whenToAdd) {
                case '1_week_before':
                    addDate.setDate(addDate.getDate() - 7);
                    break;
                case '2_weeks_before':
                    addDate.setDate(addDate.getDate() - 14);
                    break;
                case '3_days_before':
                    addDate.setDate(addDate.getDate() - 3);
                    break;
                case '1_day_before':
                    addDate.setDate(addDate.getDate() - 1);
                    break;
                default:
                    return eventDate; // immediately
            }
            
            return addDate.toISOString().split('T')[0];
        }

        // Get list type display name
        function getListTypeName(listType) {
            const names = {
                'shopping': 'Shopping',
                'personal_todos': 'Personal Todos',
                'work_todos': 'Work Todos',
                'bucket': 'Bucket List'
            };
            return names[listType] || listType;
        }

        // Add item to a specific list
        async function addItemToList(listType, itemText, priority) {
            try {
                // First, get or create a list of the specified type
                const listsResponse = await apiRequest(`/lists/${listType}`);
                let listId = null;
                
                if (listsResponse.lists && listsResponse.lists.length > 0) {
                    listId = listsResponse.lists[0].id;
                } else {
                    // Create a new list if none exists
                    const createListResponse = await apiRequest('/lists/', {
                        method: 'POST',
                        body: JSON.stringify({
                            name: getListTypeName(listType),
                            type: listType,
                            category: listType.includes('work') ? 'work' : 'personal'
                        })
                    });
                    listId = createListResponse.list_id;
                }
                
                // Add item to the list
                const itemData = {
                    text: itemText,
                    priority: priority,
                    completed: false
                };
                
                await apiRequest(`/lists/${listId}/items`, {
                    method: 'POST',
                    body: JSON.stringify(itemData)
                });
                
                console.log(`Added "${itemText}" to ${getListTypeName(listType)} list`);
            } catch (error) {
                console.error('Failed to add item to list:', error);
            }
        }

        // Ensure all changes are persistent
        async function ensurePersistence() {
            // This function ensures all changes are saved to the API
            // Individual events are saved via saveEvent(), so this is mainly for notifications
            
            try {
                // Events are saved individually via saveEvent() when created/updated
                // Tasks are saved individually via their respective APIs
                
                showNotification('Changes saved', 'success');
            } catch (error) {
                console.error('Failed to save changes:', error);
                showNotification('Some changes may not be saved', 'warning');
            }
        }
    </script>
</body>
</html>
