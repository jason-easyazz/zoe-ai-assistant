"""
Skill Generator
=================

Phase 8: Generates SKILL.md files from detected patterns.

Generated skills are saved to ~/.zoe/skills/pending/ and require
user approval before activation. They follow the same security rules
as all skills: api_only: true, allowed_endpoints whitelist.
"""

import os
import json
import logging
from typing import Dict, Any, Optional, List
from datetime import datetime
from pathlib import Path

logger = logging.getLogger(__name__)

PENDING_SKILLS_DIR = os.path.expanduser(
    os.getenv("PENDING_SKILLS_DIR", "~/.zoe/skills/pending")
)
USER_SKILLS_DIR = os.path.expanduser(
    os.getenv("USER_SKILLS_DIR", "~/.zoe/skills")
)


def generate_skill_from_pattern(
    pattern: Dict[str, Any],
    user_id: str,
    name: str = "",
    description: str = "",
) -> Dict[str, Any]:
    """Generate a SKILL.md from a detected pattern.

    Args:
        pattern: Pattern dict from pattern_detector
        user_id: The user who owns this pattern
        name: Optional custom name (auto-generated if empty)
        description: Optional description

    Returns:
        Dict with success status and skill path
    """
    action_sequence = pattern.get("action_sequence", "[]")
    if isinstance(action_sequence, str):
        try:
            action_sequence = json.loads(action_sequence)
        except Exception:
            action_sequence = []

    # Auto-generate name from actions
    if not name:
        actions_str = "-".join(action_sequence[:3]).replace(":", "-").replace(".", "-")
        name = f"auto-{actions_str}"[:40]

    if not description:
        description = pattern.get("description", "Auto-generated skill from repeated workflow")

    # Determine allowed endpoints from actions
    allowed_endpoints = _infer_endpoints(action_sequence)

    # Generate triggers from action keywords
    triggers = _infer_triggers(action_sequence)

    # Build SKILL.md content
    skill_content = f"""---
name: {name}
description: {description}
version: 1.0.0
author: zoe-self-created
api_only: true
auto_generated: true
source_pattern: "{pattern.get('occurrence_count', 0)} occurrences, user:{user_id}"
triggers:
{_yaml_list(triggers)}
allowed_endpoints:
{_yaml_list(allowed_endpoints)}
tags:
  - auto-generated
  - self-created
---
# {name.replace('-', ' ').title()}

## Auto-Generated Skill

This skill was automatically generated by Zoe based on a repeated
workflow pattern detected in your conversations.

**Pattern:** {description}
**Occurrences:** {pattern.get('occurrence_count', 0)}
**First seen:** {pattern.get('first_seen', 'unknown')}
**Last seen:** {pattern.get('last_seen', 'unknown')}

## Actions
{_format_actions(action_sequence)}

## Important
This skill was auto-generated and requires your approval to activate.
Review the actions and endpoints above to ensure they match your intent.
"""

    # Save to pending directory
    try:
        pending_dir = os.path.join(PENDING_SKILLS_DIR, name)
        os.makedirs(pending_dir, exist_ok=True)

        skill_path = os.path.join(pending_dir, "SKILL.md")
        with open(skill_path, "w") as f:
            f.write(skill_content)

        logger.info(f"Generated pending skill: {name} at {skill_path}")
        return {
            "success": True,
            "name": name,
            "path": skill_path,
            "pending": True,
        }

    except Exception as e:
        logger.error(f"Failed to generate skill: {e}")
        return {"success": False, "error": str(e)}


def approve_pending_skill(name: str) -> Dict[str, Any]:
    """Move a pending skill to the active user skills directory.

    This activates the skill in the next registry reload.
    """
    pending_path = os.path.join(PENDING_SKILLS_DIR, name, "SKILL.md")
    active_dir = os.path.join(USER_SKILLS_DIR, name)

    if not os.path.exists(pending_path):
        return {"success": False, "error": f"Pending skill '{name}' not found"}

    try:
        os.makedirs(active_dir, exist_ok=True)
        active_path = os.path.join(active_dir, "SKILL.md")

        # Copy (not move) so pending dir can be cleaned up separately
        with open(pending_path, "r") as src, open(active_path, "w") as dst:
            dst.write(src.read())

        # Remove from pending
        os.remove(pending_path)
        try:
            os.rmdir(os.path.join(PENDING_SKILLS_DIR, name))
        except OSError:
            pass

        logger.info(f"Approved skill: {name} -> {active_path}")
        return {"success": True, "name": name, "path": active_path}

    except Exception as e:
        return {"success": False, "error": str(e)}


def reject_pending_skill(name: str) -> Dict[str, Any]:
    """Reject and remove a pending skill."""
    pending_path = os.path.join(PENDING_SKILLS_DIR, name, "SKILL.md")

    if not os.path.exists(pending_path):
        return {"success": False, "error": f"Pending skill '{name}' not found"}

    try:
        os.remove(pending_path)
        try:
            os.rmdir(os.path.join(PENDING_SKILLS_DIR, name))
        except OSError:
            pass

        logger.info(f"Rejected skill: {name}")
        return {"success": True, "name": name}

    except Exception as e:
        return {"success": False, "error": str(e)}


def list_pending_skills() -> List[Dict[str, Any]]:
    """List all pending skills awaiting approval."""
    pending = []
    if not os.path.isdir(PENDING_SKILLS_DIR):
        return pending

    for entry in os.listdir(PENDING_SKILLS_DIR):
        skill_file = os.path.join(PENDING_SKILLS_DIR, entry, "SKILL.md")
        if os.path.isfile(skill_file):
            pending.append({
                "name": entry,
                "path": skill_file,
                "status": "pending_approval",
            })

    return pending


def _infer_endpoints(actions: List[str]) -> List[str]:
    """Infer allowed API endpoints from action signatures."""
    endpoint_map = {
        "intent:ListAdd": "POST /api/lists/*/items",
        "intent:CalendarCreate": "POST /api/calendar/events",
        "intent:ReminderCreate": "POST /api/reminders",
        "tool:smart_home": "POST /api/homeassistant/control",
        "routing:action": "POST /api/chat",
        "routing:intent_system": "POST /api/chat",
    }
    endpoints = set()
    for action in actions:
        if action in endpoint_map:
            endpoints.add(endpoint_map[action])
    return sorted(endpoints) or ["POST /api/chat"]


def _infer_triggers(actions: List[str]) -> List[str]:
    """Infer trigger keywords from action signatures."""
    trigger_map = {
        "intent:ListAdd": "add to list",
        "intent:CalendarCreate": "schedule",
        "intent:ReminderCreate": "remind",
        "tool:smart_home": "turn on",
    }
    triggers = set()
    for action in actions:
        if action in trigger_map:
            triggers.add(trigger_map[action])
    return sorted(triggers) or ["auto-skill"]


def _yaml_list(items: List[str]) -> str:
    """Format a list as YAML."""
    return "\n".join(f'  - "{item}"' for item in items)


def _format_actions(actions: List[str]) -> str:
    """Format action sequence as markdown."""
    if not actions:
        return "No specific actions detected."
    return "\n".join(f"- `{a}`" for a in actions)
