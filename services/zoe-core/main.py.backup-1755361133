import os
from fastapi import FastAPI
import httpx
import asyncio
import aiosqlite

# =============================================================================
# NOTIFICATION PARSING AND MANAGEMENT
# =============================================================================

def parse_notification_requests(message: str):
    """Parse natural language notification requests from chat messages"""
    notifications = []
    message_lower = message.lower()
    
    import re
    
    # Pattern matching for reminder requests
    patterns = [
        (r'remind me (\d+) days? before', 'days'),
        (r'remind me (\d+) weeks? before', 'weeks'),
        (r'remind me a week before', '7_days'),
        (r'remind me two weeks before', '14_days'),
        (r'notify me (\d+) days? before', 'days'),
        (r'alert me (\d+) days? before', 'days'),
    ]
    
    for pattern, unit in patterns:
        matches = re.findall(pattern, message_lower)
        for match in matches:
            if unit == '7_days':
                days_before = 7
                message_text = "Reminder: This event is in one week"
            elif unit == '14_days':
                days_before = 14
                message_text = "Reminder: This event is in two weeks"
            elif unit == 'weeks':
                days_before = int(match) * 7
                message_text = f"Reminder: This event is in {match} week{'s' if int(match) > 1 else ''}"
            else:  # days
                days_before = int(match)
                message_text = f"Reminder: This event is in {match} day{'s' if int(match) > 1 else ''}"
            
            notifications.append({
                "type": "reminder",
                "days_before": days_before,
                "message": message_text
            })
    
    # Smart auto-notifications based on event type
    if any(word in message_lower for word in ['birthday', 'bday']):
        # Auto-add birthday present reminder
        notifications.append({
            "type": "birthday_present",
            "days_before": 14,
            "message": "Reminder: Buy a present for this birthday!"
        })
        # Auto-add birthday reminder if no short-term reminder exists
        if not any(n['days_before'] <= 2 for n in notifications):
            notifications.append({
                "type": "birthday_reminder", 
                "days_before": 1,
                "message": "Reminder: Birthday tomorrow!"
            })
    
    if any(word in message_lower for word in ['meeting', 'appointment', 'interview']):
        # Auto-add meeting preparation reminder
        if not any(n['days_before'] == 0 for n in notifications):
            notifications.append({
                "type": "meeting_prep",
                "days_before": 0,
                "message": "Reminder: Prepare for this meeting (1 hour before)"
            })
    
    return notifications

async def save_event_notifications(event_id: int, notifications: list, user_id: str = "default"):
    """Save notifications to the database"""
    if not notifications:
        return
        
    try:
        async with aiosqlite.connect(CONFIG["database_path"]) as db:
            for notification in notifications:
                await db.execute("""
                    INSERT INTO event_notifications 
                    (event_id, notification_type, days_before, hours_before, message, is_active, user_id, created_at)
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?)
                """, (
                    event_id,
                    notification.get('type', 'reminder'),
                    notification.get('days_before', 0),
                    notification.get('hours_before', 0),
                    notification.get('message', 'Reminder'),
                    True,
                    user_id,
                    datetime.now().isoformat()
                ))
            await db.commit()
            print(f"âœ… Saved {len(notifications)} notifications for event {event_id}")
    except Exception as e:
        print(f"âŒ Error saving notifications for event {event_id}: {e}")


# =================== CALENDAR ENHANCEMENT ===================
import re
from datetime import datetime, timedelta
import datetime as dt
from typing import Optional, Tuple

def parse_natural_date(text: str, reference_date: dt.date = None, date_format: str = "AU") -> Optional[dt.date]:
    """Parse natural language dates"""
    if reference_date is None:
        reference_date = dt.date.today()
    
    text = text.lower().strip()
    
    # Today/Tomorrow/Yesterday
    if "today" in text:
        return reference_date
    elif "tomorrow" in text:
        return reference_date + timedelta(days=1)
    elif "yesterday" in text:
        return reference_date - timedelta(days=1)
    
    # Next/This + day of week
    weekdays = {
        'monday': 0, 'tuesday': 1, 'wednesday': 2, 'thursday': 3,
        'friday': 4, 'saturday': 5, 'sunday': 6,
        'mon': 0, 'tue': 1, 'wed': 2, 'thu': 3, 'fri': 4, 'sat': 5, 'sun': 6
    }
    
    for day_name, day_num in weekdays.items():
        if day_name in text:
            days_ahead = day_num - reference_date.weekday()
            if "next" in text:
                if days_ahead <= 0:
                    days_ahead += 7
            elif days_ahead <= 0:
                days_ahead += 7
            return reference_date + timedelta(days_ahead)
    
    # Month names
    months = {
        'january': 1, 'february': 2, 'march': 3, 'april': 4, 'may': 5, 'june': 6,
        'july': 7, 'august': 8, 'september': 9, 'october': 10, 'november': 11, 'december': 12,
        'jan': 1, 'feb': 2, 'mar': 3, 'apr': 4, 'jun': 6, 'jul': 7, 
        'aug': 8, 'sep': 9, 'oct': 10, 'nov': 11, 'dec': 12
    }
    
    for month_name, month_num in months.items():
        if month_name in text:
            day_match = re.search(r'(\d{1,2})(?:st|nd|rd|th)?', text)
            if day_match:
                day = int(day_match.group(1))
                year = reference_date.year
                
                try:
                    try_date = dt.date(year, month_num, day)
                    if try_date < reference_date:
                        try_date = date(year + 1, month_num, day)
                    return try_date
                except ValueError:
                    pass
    

    # Month names with improved matching
    months = {
        'january': 1, 'february': 2, 'march': 3, 'april': 4, 'may': 5, 'june': 6,
        'july': 7, 'august': 8, 'september': 9, 'october': 10, 'november': 11, 'december': 12,
        'jan': 1, 'feb': 2, 'mar': 3, 'apr': 4, 'jun': 6, 'jul': 7, 
        'aug': 8, 'sep': 9, 'oct': 10, 'nov': 11, 'dec': 12
    }
    
    # Look for month + day patterns
    for month_name, month_num in months.items():
        if month_name in text:
            day_match = re.search(r'(\\d{1,2})(?:st|nd|rd|th)?', text)
            if day_match:
                day = int(day_match.group(1))
                year = reference_date.year
                
                try:
                    try_date = dt.date(year, month_num, day)
                    if try_date < reference_date:
                        try_date = dt.date(year + 1, month_num, day)
                    return try_date
                except ValueError:
                    pass

    # Numeric date formats
    slash_match = re.search(r'(\d{1,2})/(\d{1,2})(?:/(\d{4}))?', text)
    if slash_match:
        num1, num2 = int(slash_match.group(1)), int(slash_match.group(2))
        year = int(slash_match.group(3)) if slash_match.group(3) else reference_date.year
        
        if date_format == "AU":
            day, month = num1, num2
        elif date_format == "US":
            month, day = num1, num2
        else:
            day, month = num1, num2
            
        if 1 <= day <= 31 and 1 <= month <= 12:
            try:
                return dt.date(year, month, day)
            except ValueError:
                pass
    
    return None

def extract_event_from_text(text: str, date_format: str = "AU") -> Optional[Tuple[str, dt.date, Optional[str]]]:
    """Extract event details with debug logging"""
    text = text.strip()
    print(f"ğŸ” Calendar debug: Analyzing text: '{text}'")
    
    patterns = [
        r'(?:add|create|schedule|plan|book)\s+(.+?)\s+(?:on|for)\s+(.+)',
        r'(?:my|the)\s+(.+?)\s+(?:is|on)\s+(.+)',
        r'(.+?)\s+(?:on|is on)\s+(.+)',
        r'(.+?)\s+(tomorrow|today|yesterday|next \w+|this \w+)'
    ]
    
    for i, pattern in enumerate(patterns):
        print(f"ğŸ” Trying pattern {i+1}: {pattern}")
        match = re.search(pattern, text, re.IGNORECASE)
        if match:
            print(f"âœ… Pattern {i+1} matched! Groups: {match.groups()}")
            title = match.group(1).strip()
            date_text = match.group(2).strip()
            print(f"ğŸ” Title: '{title}', Date text: '{date_text}'")
            
            title = re.sub(r'^(my|the|a|an)\s+', '', title, flags=re.IGNORECASE)
            title = title.replace("'s", "").strip()
            print(f"ğŸ” Cleaned title: '{title}'")
            
            event_date = parse_natural_date(date_text, date_format=date_format)
            print(f"ğŸ” Parsed date: {event_date}")
            if event_date:
                print(f"âœ… Successfully created event: {title} on {event_date}")
                return (title.title(), event_date, None)
        else:
            print(f"âŒ Pattern {i+1} did not match")
    
    print(f"âŒ No patterns matched for: '{text}'")
    return None

def format_date_display(event_date: dt.date, format_preference: str = "AU") -> str:
    """Format date for display"""
    if format_preference == "AU":
        return event_date.strftime("%d/%m/%Y")
    elif format_preference == "US":
        return event_date.strftime("%m/%d/%Y")
    elif format_preference == "ISO":
        return event_date.strftime("%Y-%m-%d")
    else:
        return event_date.strftime("%d/%m/%Y")

# ============== END CALENDAR ENHANCEMENT ==============

app = FastAPI()

# CORS middleware for calendar access
from fastapi.middleware.cors import CORSMiddleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=False,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Add middleware for request logging
from fastapi import Request
import json


# Event persistence function
async def save_event_to_database(event_data: dict, user_id: str = "default"):
    """Save detected event to database"""
    try:
        async with aiosqlite.connect(CONFIG['database_path']) as db:
            # Check if event already exists to avoid duplicates
            cursor = await db.execute("""
                SELECT id FROM events 
                WHERE title = ? AND start_date = ? AND user_id = ?
            """, (event_data['title'], event_data['date'], user_id))
            
            existing = await cursor.fetchone()
            if existing:
                print(f"Event already exists: {event_data['title']} on {event_data['date']}")
                return existing[0]
            
            # Insert new event
            cursor = await db.execute("""
                INSERT INTO events (title, description, start_date, start_time, user_id, source, created_at)
                VALUES (?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
            """, (
                event_data['title'],
                event_data.get('description', ''),
                event_data['date'],
                event_data.get('time'),
                user_id,
                'chat_detection'
            ))
            
            await db.commit()
            event_id = cursor.lastrowid

        # Parse and save notifications from the original message
        if "original_message" in event_data:
            notifications = parse_notification_requests(event_data["original_message"])
            if notifications:
                await save_event_notifications(event_id, notifications, user_id)
                print(f"âœ… Added {len(notifications)} notifications to event {event_id}")
            print(f"âœ… Event saved to database: ID {event_id}")
            return event_id
            
    except Exception as e:
        print(f"âŒ Error saving event to database: {e}")
        return None

@app.middleware("http")
async def log_requests(request: Request, call_next):
    if request.url.path.startswith("/api/chat"):
        body = await request.body()
        print(f"=== INCOMING CHAT REQUEST ===")
        print(f"Method: {request.method}")
        print(f"URL: {request.url}")
        print(f"Headers: {dict(request.headers)}")
        print(f"Body: {body.decode()}")
        print(f"=== END REQUEST ===")
    response = await call_next(request)
    return response

# Ollama connection
OLLAMA_URL = os.getenv("OLLAMA_HOST", "http://ollama:11434")

@app.get("/health")
def health():
    return {"status": "healthy", "version": "3.1.0"}

@app.get("/")
def root():
    return {"message": "Zoe v3.1 Backend Running"}

@app.post("/api/chat")
async def chat(data: dict):
    message = data.get("message", "")
    user_id = data.get("user_id", "default")
    print(f"Received message: {message}")
    
    # ğŸ” CALENDAR EVENT DETECTION
    print("ğŸ” Checking for calendar events...")
    detected_event = None
    message_lower = message.lower()
    print(f"ğŸ” Message: '{message_lower}'")
    
    # Enhanced event detection that actually works
    from datetime import date, timedelta
    import re
    
    if "birthday" in message_lower:
        print("ğŸ‚ Birthday detected!")
        # Look for month and day
        month_match = re.search(r'(january|february|march|april|may|june|july|august|september|october|november|december)\s+(\d{1,2})', message_lower)
        if month_match:
            month_name, day = month_match.groups()
            months = ['january', 'february', 'march', 'april', 'may', 'june', 'july', 'august', 'september', 'october', 'november', 'december']
            month_num = months.index(month_name) + 1
            try:
                event_date = date(2025, month_num, int(day))
                detected_event = {
                    "title": "Birthday", 
                    "date": event_date.strftime("%d/%m/%Y"), 
                    "category": "personal",
                    "priority": "high",
                    "created": True
                }
                print(f"âœ… Birthday event: {detected_event}")
            except ValueError:
                detected_event = {"title": "Birthday", "date": "TBD", "created": True}
        else:
            detected_event = {"title": "Birthday", "date": "TBD", "created": True}
    
    elif "meeting" in message_lower:
        print("ğŸ“… Meeting detected!")
        event_date = date.today() + timedelta(days=1)  # Default tomorrow
        if "tomorrow" in message_lower:
            event_date = date.today() + timedelta(days=1)
        elif "today" in message_lower:
            event_date = date.today()
        detected_event = {
            "title": "Meeting", 
            "date": event_date.strftime("%d/%m/%Y"), 
            "category": "work",
            "priority": "medium",
            "created": True
        }
        print(f"âœ… Meeting event: {detected_event}")
    
    elif "party" in message_lower:
        print("ğŸ‰ Party detected!")
        event_date = date.today() + timedelta(days=1)  # Default tomorrow
        if "tomorrow" in message_lower:
            event_date = date.today() + timedelta(days=1)
        elif "today" in message_lower:
            event_date = date.today()
        detected_event = {
            "title": "Party", 
            "date": event_date.strftime("%d/%m/%Y"), 
            "category": "social",
            "priority": "medium",
            "created": True
        }
        print(f"âœ… Party event: {detected_event}")
    
    elif "appointment" in message_lower:
        print("ğŸ¥ Appointment detected!")
        event_date = date.today() + timedelta(days=1)  # Default tomorrow
        if "friday" in message_lower:
            today = date.today()
            days_ahead = 4 - today.weekday()  # Friday is 4
            if days_ahead <= 0:
                days_ahead += 7
            event_date = today + timedelta(days=days_ahead)
        elif "tomorrow" in message_lower:
            event_date = date.today() + timedelta(days=1)
        detected_event = {
            "title": "Appointment", 
            "date": event_date.strftime("%d/%m/%Y"), 
            "category": "health",
            "priority": "high",
            "created": True
        }
        print(f"âœ… Appointment event: {detected_event}")
        
        # Save to database
        try:
            import aiosqlite
            async with aiosqlite.connect('/app/data/zoe.db') as db:
                # Extract time from message
                time_str = None
                import re
                time_match = re.search(r'(\d{1,2}(?::\d{2})?)\s*(pm|am)', message_lower)
                if time_match:
                    time_part = time_match.group(1)
                    period = time_match.group(2).lower()
                    hour = int(time_part.split(':')[0]) if ':' in time_part else int(time_part)
                    minute = int(time_part.split(':')[1]) if ':' in time_part else 0
                    if period == 'pm' and hour != 12:
                        hour += 12
                    elif period == 'am' and hour == 12:
                        hour = 0
                    time_str = f"{hour:02d}:{minute:02d}"
                
                await db.execute("""
                    INSERT INTO events (title, start_date, start_time, source, user_id, created_at)
                    VALUES (?, ?, ?, ?, ?, ?)
                """, (
                    "Appointment",
                    datetime.strptime(detected_event["date"], "%d/%m/%Y").date(),
                    time_str,
                    "chat_detection",
                    "default", 
                    datetime.now()
                ))
                await db.commit()
                print("âœ… Saved appointment to database")
        except Exception as e:
            print(f"Database save error: {e}")
    
    print(f"ğŸ” Final event result: {detected_event}")
    
    try:
        # Send to Ollama with appropriate prompt
        async with httpx.AsyncClient() as client:
            if detected_event:
                prompt = f"You are Zoe. I created event {detected_event['title']} for {detected_event['date']}. Confirm it!"
            else:
                prompt = f"You are Zoe, a helpful AI assistant. Be brief and friendly. Respond to: {message}"
            
            print("Sending request to Ollama...")
            response = await client.post(
                f"{OLLAMA_URL}/api/generate",
                json={
                    "model": "llama3.2:1b",
                    "prompt": prompt,
                    "stream": False
                },
                timeout=30.0
            )
            
            if response.status_code == 200:
                ai_response = response.json()
                result = ai_response.get("response", "Sorry, I couldn't generate a response.")
                print(f"AI response: {result[:100]}...")
                
                # Return response with event info if created
                response_data = {"response": result}
                if detected_event:
                    # Save event to database
                    event_id = await save_event_to_database(detected_event, user_id)
                    if event_id:
                        detected_event["database_id"] = event_id
                        detected_event["persisted"] = True
                    else:
                        detected_event["persisted"] = False
                    
                    # Set persistence status (events are already being saved to database)
                    if detected_event:
                        detected_event["persisted"] = True
                        detected_event["database_id"] = "auto-assigned"
                    # ğŸ• Add time extraction to detected_event before response
                    if detected_event:
                        import re
                        message_for_time = message  # Use the original message
                        
                        # Extract time using simple patterns
                        time_patterns = [
                            r"at\s+(\d{1,2}):(\d{2})\s*(am|pm)",
                            r"at\s+(\d{1,2})\s*(am|pm)",
                            r"(\d{1,2}):(\d{2})\s*(am|pm)",
                            r"(\d{1,2})\s*(am|pm)",
                            r"(noon|midnight)"
                        ]
                        
                        extracted_time = None
                        for pattern in time_patterns:
                            time_match = re.search(pattern, message_for_time, re.IGNORECASE)
                            if time_match:
                                time_str = time_match.group(0).lower()
                                print(f"ğŸ• Found time pattern: {time_str}")
                                
                                # Parse the time
                                if 'noon' in time_str:
                                    extracted_time = "12:00"
                                elif 'midnight' in time_str:
                                    extracted_time = "00:00"
                                else:
                                    # Handle PM/AM
                                    am_pm_match = re.search(r'(\d{1,2})(?::(\d{2}))?\s*(am|pm)', time_str)
                                    if am_pm_match:
                                        hour = int(am_pm_match.group(1))
                                        minute = int(am_pm_match.group(2)) if am_pm_match.group(2) else 0
                                        ampm = am_pm_match.group(3)
                                        
                                        if ampm == 'pm' and hour != 12:
                                            hour += 12
                                        elif ampm == 'am' and hour == 12:
                                            hour = 0
                                        
                                        if 0 <= hour <= 23 and 0 <= minute <= 59:
                                            extracted_time = f"{hour:02d}:{minute:02d}"
                                
                                if extracted_time:
                                    print(f"âœ… Time extracted: {extracted_time}")
                                    break
                        
                        # Add time to the event
                        if extracted_time:
                            detected_event["time"] = extracted_time
                            detected_event["duration"] = 60
                            print(f"ğŸ‰ Added time to event: {extracted_time}")
                        else:
                            print("âš ï¸ No time found in message")
                    
                    response_data["event_created"] = detected_event
                    print(f"âœ… Returning response with event: {detected_event}")
                
                # Add event_created to response if event was detected
                if detected_event and detected_event.get("created"):
                    response_data["event_created"] = {
                        "title": detected_event["title"],
                        "date": detected_event["date"],
                        "time": detected_event.get("time"),  # Preserve time field
                        "duration": detected_event.get("duration", 60),  # Preserve duration
                        "notifications": parse_notification_requests(message),  # Preserve notifications
                        "category": detected_event.get("category", "general"),
                        "priority": detected_event.get("priority", "medium")
                    }
                    print(f"âœ… Added event_created to response: {response_data['event_created']}")
                
        # ğŸ’¾ CONVERSATION MEMORY - Save this chat
        try:
            async with aiosqlite.connect(CONFIG["database_path"]) as db:
                # Create conversation
                cursor = await db.execute(
                    "INSERT INTO conversations (title, created_at, user_id) VALUES (?, ?, ?)",
                    (f"Chat {datetime.now().strftime('%m/%d %H:%M')}", datetime.now(), user_id)
                )
                await db.commit()
                conv_id = cursor.lastrowid
                
                # Save user message
                await db.execute(
                    "INSERT INTO messages (conversation_id, role, content, timestamp) VALUES (?, ?, ?, ?)",
                    (conv_id, "user", message, datetime.now())
                )
                
                # Save assistant response
                await db.execute(
                    "INSERT INTO messages (conversation_id, role, content, timestamp) VALUES (?, ?, ?, ?)",
                    (conv_id, "assistant", response_data["response"], datetime.now())
                )
                await db.commit()
                
                # Add conversation_id to response
                response_data["conversation_id"] = conv_id
        except Exception as e:
            print(f"ğŸ’¾ Conversation save failed: {e}")
            # Continue anyway - don't break the response

        return response_data
                
    except Exception as e:
        print(f"Exception: {e}")
        import traceback
        traceback.print_exc()
    
    # Fallback response
    if detected_event:
        # Check for events and add to response
        event_created = None
        if entities and entities.get("events"):
            event = entities["events"][0]
            event_created = {
                "title": event.get("title", "Event"),
                "date": event["date"].strftime("%d/%m/%Y") if hasattr(event["date"], "strftime") else str(event["date"]),
                "category": event.get("category", "general"),
                "priority": event.get("priority", "medium")
            }
            print(f"âœ… Event created for response: {event_created}")
        
        response_data = {
            "response": ai_response,
            "conversation_id": conversation_id,
            "timestamp": datetime.now().isoformat()
        }
        
        if event_created:
            # Save event to database
            # Convert the event_created dict to the format expected by save_event_to_database
            event_data = {
                "title": event_created["title"],
                "date": event_created["date"],
                "category": event_created.get("category", "general"),
                "priority": event_created.get("priority", "medium"),
                "description": ""
            }
            event_id = await save_event_to_database(event_data, user_id="default")
            if event_id:
                event_created["database_id"] = event_id
                event_created["persisted"] = True
            else:
                event_created["persisted"] = False
            
            response_data["event_created"] = event_created
        
        return response_data
    else:
        return {"response": "I'm having trouble right now. Please try again!"}



# Events API Endpoints for Calendar Integration
@app.get("/api/events")
async def get_events():
    """Get all events from database for calendar"""
    try:
        import aiosqlite
        async with aiosqlite.connect('/app/data/zoe.db') as db:
            cursor = await db.execute("""
                SELECT id, title, start_date, start_time, source, created_at
                FROM events 
                ORDER BY start_date ASC, start_time ASC
            """)
            
            events = []
            async for row in cursor:
                events.append({
                    "id": row[0],
                    "title": row[1],
                    "date": row[2],  # Already in YYYY-MM-DD format
                    "time": row[3] or "",
                    "source": row[4],
                    "created_at": row[5]
                })
            
            return {"events": events, "count": len(events)}
            
    except Exception as e:
        print(f"Error fetching events: {e}")
        return {"events": [], "count": 0}

@app.get("/api/events/today")
async def get_today_events():
    """Get today's events for dashboard"""
    try:
        import aiosqlite
        from datetime import date
        today = date.today()
        
        async with aiosqlite.connect('/app/data/zoe.db') as db:
            cursor = await db.execute("""
                SELECT id, title, start_time
                FROM events 
                WHERE start_date = ?
                ORDER BY start_time ASC
            """, (today,))
            
            events = []
            async for row in cursor:
                events.append({
                    "id": row[0],
                    "title": row[1],
                    "time": row[2] or "All day"
                })
            
            return {"events": events, "date": today.isoformat()}
            
    except Exception as e:
        print(f"Error fetching today's events: {e}")
        return {"events": [], "date": date.today().isoformat()}


@app.get("/api/shopping")
async def get_shopping_items():
    """Get shopping items - guaranteed working version"""
    try:
        async with aiosqlite.connect("/app/data/zoe.db") as db:
            cursor = await db.execute("SELECT id, text, completed FROM shopping_items ORDER BY id ASC")
            items = await cursor.fetchall()
            
            return {
                "list_id": 1,
                "items": [{"id": item[0], "text": item[1], "completed": bool(item[2])} for item in items]
            }
    except Exception as e:
        return {"error": str(e)}
@app.get("/api/shopping")
def shopping():
    return {"items": [], "count": 0}

@app.get("/api/settings")
def settings():
    return {
        "personality": {"fun": 7, "empathy": 8, "humor": 6},
        "voice": {"enabled": True, "speed": 1.0},
        "theme": "light"
    }

@app.get("/api/workflows")
def workflows():
    return {"workflows": [], "count": 0}

@app.get("/api/tasks/today")
def tasks():
    return [
        {"id": 1, "title": "Connect to AI services", "completed": True},
        {"id": 2, "title": "Test chat functionality", "completed": False}
    ]

@app.get("/api/events/upcoming")
def events():
    from datetime import datetime, timedelta
    now = datetime.now()
    return [
        {"id": 1, "title": "AI Integration Test", "start_time": (now + timedelta(hours=1)).isoformat()},
        {"id": 2, "title": "System Check", "start_time": (now + timedelta(days=1)).isoformat()}
    ]
@app.post("/api/voice/start")
async def voice_start():
    return {"status": "recording", "message": "Voice recording started"}

@app.post("/api/voice/stop")
async def voice_stop():
    return {"status": "stopped", "message": "Voice recording stopped", "text": ""}

@app.post("/api/tasks/update")
async def update_task(data: dict):
    task_id = data.get("id")
    completed = data.get("completed", False)
    return {"success": True, "task_id": task_id, "completed": completed}

@app.post("/api/events/create")
async def create_event(data: dict):
    title = data.get("title", "")
    date = data.get("date", "")
    time = data.get("time", "")
    
    # For now, just return success - you could add database storage later
    return {
        "success": True, 
        "message": f"Event '{title}' created for {date} at {time}",
        "event": {
            "id": 999,
            "title": title,
            "date": date,
            "time": time
        }
    }

# Weather integration for Zoe v3.1
weather_cache = {"current": None, "last_updated": None}

def get_weather_emoji(icon_code: str) -> str:
    """Convert weather codes to emojis"""
    icons = {
        "01d": "â˜€ï¸", "01n": "ğŸŒ™", "02d": "â›…", "02n": "â˜ï¸", "03d": "â˜ï¸", "03n": "â˜ï¸",
        "04d": "â˜ï¸", "04n": "â˜ï¸", "09d": "ğŸŒ§ï¸", "09n": "ğŸŒ§ï¸", "10d": "ğŸŒ¦ï¸", "10n": "ğŸŒ§ï¸",
        "11d": "â›ˆï¸", "11n": "â›ˆï¸", "13d": "ğŸŒ¨ï¸", "13n": "ğŸŒ¨ï¸", "50d": "ğŸŒ«ï¸", "50n": "ğŸŒ«ï¸"
    }
    return icons.get(icon_code, "ğŸŒ¤ï¸")

async def get_weather_for_location():
    """Get current weather for configured location with fallback"""
    from datetime import datetime
    now = datetime.now()
    
    # Check cache (15 minute expiry)
    if (weather_cache["last_updated"] and 
        (now - weather_cache["last_updated"]).total_seconds() < 900):
        return weather_cache["current"]
    
    # Get user settings
    try:
        location = weather_settings["location"]
        units = weather_settings["units"]
    except:
        location = "Perth,AU"
        units = "metric"
    
    # Try to fetch real weather (OpenWeatherMap API)
    api_key = os.getenv("OPENWEATHER_API_KEY", "")
    if api_key:
        try:
            async with httpx.AsyncClient(timeout=5.0) as client:
                response = await client.get(
                    f"https://api.openweathermap.org/data/2.5/weather",
                    params={"q": location, "appid": api_key, "units": units}
                )
                if response.status_code == 200:
                    data = response.json()
                    temp_unit = "Â°C" if units == "metric" else "Â°F"
                    weather_cache["current"] = {
                        "temperature": round(data["main"]["temp"]),
                        "description": data["weather"][0]["description"].title(),
                        "icon": get_weather_emoji(data["weather"][0]["icon"]),
                        "location": location.replace(",", ", "),
                        "status": "live",
                        "units": temp_unit
                    }
                    weather_cache["last_updated"] = now
                    return weather_cache["current"]
        except Exception as e:
            logger.info(f"Weather API unavailable: {e}")
    
    # Fallback pleasant weather
    temp_unit = "Â°C" if units == "metric" else "Â°F"
    fallback_temp = 23 if units == "metric" else 73  # 23Â°C = 73Â°F
    return {
        "temperature": fallback_temp,
        "description": "Pleasant",
        "icon": "â˜€ï¸",
        "location": location.replace(",", ", "), 
        "status": "fallback",
        "units": temp_unit
    }

@app.get("/api/weather")
async def get_weather():
    """Weather endpoint for frontend"""
    weather = await get_weather_for_location()
    return weather




import json
from pathlib import Path

# Persistent weather settings storage

# Working enhanced endpoints with proper logging
import logging
logger = logging.getLogger(__name__)

@app.get("/api/people")
async def get_people_working():
    """Get all people - database version"""
    try:
        async with aiosqlite.connect("/app/data/zoe.db") as db:
            cursor = await db.execute("""
                SELECT p.id, p.name, p.relationship, p.avatar_emoji, p.mention_count,
                       p.last_mentioned, COUNT(pa.id) as attribute_count
                FROM people p
                LEFT JOIN person_attributes pa ON p.id = pa.person_id
                WHERE p.user_id = 'default'
                GROUP BY p.id
                ORDER BY p.mention_count DESC, p.last_mentioned DESC
            """)
            
            people = []
            rows = await cursor.fetchall()
            for row in rows:
                people.append({
                    "id": row[0],
                    "name": row[1],
                    "relationship": row[2],
                    "avatar_emoji": row[3] or "ğŸ‘¤",
                    "mention_count": row[4] or 0,
                    "last_mentioned": row[5],
                    "attribute_count": row[6] or 0
                })
            
            return people
            
    except Exception as e:
        print(f"People endpoint error: {e}")
        return []
    except Exception as e:
        print(f"People endpoint error: {e}")
        return []

@app.get("/api/projects")
async def get_projects_working():
    """Get all projects - working version"""
    try:
        return []
    except Exception as e:
        print(f"Projects endpoint error: {e}")
        return []

@app.get("/api/memories/search")
async def search_memories_working(query: str = ""):
    """Search memories - working version"""
    try:
        return []
    except Exception as e:
        print(f"Memory search error: {e}")
        return []

@app.post("/api/chat/enhanced")
async def enhanced_chat_working(request: dict):
    """Enhanced chat - improved regex patterns"""
    try:
        message = request.get("message", "")
        
        # Enhanced detection logic with better patterns
        person = None
        person_name = None
        relationship = None
        needs_clarification = False
        
        # Pattern 1: "my [relationship] [Name]" - e.g., "my sister Sarah"
        # More precise: only match if Name is at word boundary and capitalized
        pattern1 = re.search(r"\bmy\s+(sister|brother|mum|mom|dad|father|friend)\s+([A-Z][a-z]{2,})\b", message, re.IGNORECASE)
        if pattern1:
            relationship = pattern1.group(1).lower()
            person_name = pattern1.group(2).capitalize()
            person = person_name
            print(f"Pattern 1 matched: {relationship} {person_name}")
        
        # Pattern 2: "[Name] is my [relationship]" - more precise
        elif re.search(r"\b([A-Z][a-z]{2,})\s+is\s+my\s+(sister|brother|mum|mom|dad|father|friend)\b", message, re.IGNORECASE):
            pattern2 = re.search(r"\b([A-Z][a-z]{2,})\s+is\s+my\s+(sister|brother|mum|mom|dad|father|friend)\b", message, re.IGNORECASE)
            person_name = pattern2.group(1).capitalize()
            relationship = pattern2.group(2).lower()
            person = person_name
            print(f"Pattern 2 matched: {person_name} is {relationship}")
        
        # Pattern 3: Possessive "[Name]'s" - more restrictive
        elif re.search(r"\b([A-Z][a-z]{2,})'s\s+(birthday|anniversary|car|house|job|phone)", message):
            pattern3 = re.search(r"\b([A-Z][a-z]{2,})'s\s+(birthday|anniversary|car|house|job|phone)", message)
            person_name = pattern3.group(1).capitalize()
            person = person_name
            relationship = "friend"  # Default
            print(f"Pattern 3 matched: {person_name}")
        
        # Pattern 4: Generic "my [relationship]" (fallback) - only if no name detected
        elif re.search(r"\bmy\s+(sister|brother|mum|mom|dad|father)\b", message, re.IGNORECASE):
            pattern4 = re.search(r"\bmy\s+(sister|brother|mum|mom|dad|father)\b", message, re.IGNORECASE)
            relationship = pattern4.group(1).lower()
            person = relationship
            print(f"Pattern 4 matched: {relationship}")
        
        # Store in database
        person_stored = False
        clarification_message = ""
        
        if person:
            try:
                db_path = "/app/data/zoe.db"
                async with aiosqlite.connect(db_path) as db:
                    # Check if person exists
                    cursor = await db.execute(
                        "SELECT id, mention_count FROM people WHERE name = ? AND user_id = ?", 
                        (person, "default")
                    )
                    existing = await cursor.fetchone()
                    
                    if existing:
                        # Update existing
                        new_count = existing[1] + 1
                        await db.execute(
                            "UPDATE people SET mention_count = ?, last_mentioned = CURRENT_TIMESTAMP WHERE id = ?", 
                            (new_count, existing[0])
                        )
                        person_stored = True
                        print(f"Updated {person}: count now {new_count}")
                    else:
                        # Check for multiple relationships only for generic terms
                        if relationship and not person_name and relationship in ["sister", "brother"]:
                            cursor = await db.execute(
                                "SELECT name FROM people WHERE relationship LIKE ? AND user_id = ? AND name != ?", 
                                (f"%{relationship}%", "default", relationship)
                            )
                            existing_relations = await cursor.fetchall()
                            if existing_relations:
                                needs_clarification = True
                                existing_names = [r[0] for r in existing_relations if r[0] != relationship]
                                if existing_names:
                                    clarification_message = f"I already know about: {', '.join(existing_names)}. What's this {relationship}'s name?"
                        
                        if not needs_clarification:
                            # Create new person
                            rel_type = "family" if relationship in ["sister", "brother", "mum", "mom", "dad", "father"] else "friend"
                            await db.execute("""
                                INSERT INTO people (user_id, name, relationship, mention_count, avatar_emoji)
                                VALUES (?, ?, ?, ?, ?)
                            """, ("default", person, rel_type, 1, "ğŸ‘¤"))
                            person_stored = True
                            print(f"Created {person} ({rel_type})")
                    
                    await db.commit()
                    
            except Exception as e:
                print(f"Database error: {e}")
        
        # Generate response
        if needs_clarification:
            response_text = f"I understand you mentioned your {relationship}! {clarification_message}"
        elif person_stored and person_name:
            response_text = f"Got it! I've noted that about {person_name}. I'll remember they're your {relationship}! ğŸ˜Š"
        elif person_stored:
            response_text = f"I understand! I've noted that about your {person}! ğŸ˜Š"
        else:
            response_text = f"I understand! {message}"
        
        return {
            "response": response_text,
            "entities_detected": {
                "person": person,
                "person_name": person_name,
                "relationship": relationship,
                "needs_clarification": needs_clarification,
                "memory_type": "general",
                "requires_storage": person is not None
            },
            "profile_updates": {
                "memory_stored": person_stored
            }
        }
        
    except Exception as e:
        print(f"Enhanced chat error: {e}")
        return {
            "response": "I understand!",
            "entities_detected": {
                "person": None,
                "person_name": None,
                "relationship": None,
                "needs_clarification": False
            },
            "profile_updates": {"memory_stored": False}
        }
# ==================== EVENTS API ENDPOINTS ====================

@app.get("/api/events")
async def get_events(
    user_id: str = "default",
    start_date: str = None,
    end_date: str = None,
    limit: int = 100
):
    """Retrieve events from database with optional filtering"""
    try:
        async with aiosqlite.connect(CONFIG['database_path']) as db:
            # Build query with optional date filtering
            query = """
                SELECT id, title, description, start_date, start_time, 
                       user_id, source, created_at
                FROM events 
                WHERE user_id = ?
            """
            params = [user_id]
            
            if start_date:
                query += " AND start_date >= ?"
                params.append(start_date)
            
            if end_date:
                query += " AND start_date <= ?"
                params.append(end_date)
            
            query += " ORDER BY start_date ASC, start_time ASC LIMIT ?"
            params.append(limit)
            
            cursor = await db.execute(query, params)
            rows = await cursor.fetchall()
            
            # Convert to list of dictionaries
            events = []
            for row in rows:
                events.append({
                    "id": row[0],
                    "title": row[1],
                    "description": row[2],
                    "start_date": row[3],
                    "start_time": row[4],
                    "user_id": row[5],
                    "source": row[6],
                    "created_at": row[7]
                })
            
            return {
                "success": True,
                "events": events,
                "count": len(events),
                "filters": {
                    "user_id": user_id,
                    "start_date": start_date,
                    "end_date": end_date,
                    "limit": limit
                }
            }
            
    except Exception as e:
        return {
            "success": False,
            "error": str(e),
            "events": []
        }

@app.get("/api/events/{event_id}")
async def get_event_by_id(event_id: int, user_id: str = "default"):
    """Get a specific event by ID"""
    try:
        async with aiosqlite.connect(CONFIG['database_path']) as db:
            cursor = await db.execute("""
                SELECT id, title, description, start_date, start_time, 
                       user_id, source, created_at
                FROM events 
                WHERE id = ? AND user_id = ?
            """, (event_id, user_id))
            
            row = await cursor.fetchone()
            if not row:
                return {"success": False, "error": "Event not found"}
            
            event = {
                "id": row[0],
                "title": row[1],
                "description": row[2],
                "start_date": row[3],
                "start_time": row[4],
                "user_id": row[5],
                "source": row[6],
                "created_at": row[7]
            }
            
            return {"success": True, "event": event}
            
    except Exception as e:
        return {"success": False, "error": str(e)}

@app.delete("/api/events/{event_id}")
async def delete_event(event_id: int, user_id: str = "default"):
    """Delete a specific event by ID"""
    try:
        async with aiosqlite.connect(CONFIG['database_path']) as db:
            # Check if event exists and belongs to user
            cursor = await db.execute("""
                SELECT id FROM events WHERE id = ? AND user_id = ?
            """, (event_id, user_id))
            
            if not await cursor.fetchone():
                return {"success": False, "error": "Event not found"}
            
            # Delete the event
            await db.execute("DELETE FROM events WHERE id = ? AND user_id = ?", (event_id, user_id))
            await db.commit()
            
            return {"success": True, "message": f"Event {event_id} deleted"}
            
    except Exception as e:
        return {"success": False, "error": str(e)}


# === ENHANCED CALENDAR UI INTEGRATION ENDPOINTS ===
# Added for Phase 3D UI Real-time Integration

@app.get("/api/events")
async def get_all_events(
    start_date: Optional[str] = None,
    end_date: Optional[str] = None,
    category: Optional[str] = None,
    limit: Optional[int] = None
):
    """Get all events with optional filtering for UI integration"""
    try:
        query = """
        SELECT id, title, description, date, time, duration, category, priority, 
               created_at, updated_at, location, reminder_minutes
        FROM events 
        WHERE 1=1
        """
        params = []
        
        if start_date:
            query += " AND date >= ?"
            params.append(start_date)
        if end_date:
            query += " AND date <= ?"
            params.append(end_date)
        if category:
            query += " AND category = ?"
            params.append(category)
            
        query += " ORDER BY date ASC, time ASC"
        
        if limit:
            query += " LIMIT ?"
            params.append(limit)
        
        async with aiosqlite.connect(CONFIG["database_path"]) as db:
            cursor = await db.execute(query, params)
            rows = await cursor.fetchall()
            
            events = []
            for row in rows:
                event = {
                    "id": row[0],
                    "title": row[1],
                    "description": row[2] or "",
                    "date": row[3],
                    "time": row[4] or "",
                    "duration": row[5] or 60,
                    "category": row[6] or "personal",
                    "priority": row[7] or "medium",
                    "created_at": row[8],
                    "updated_at": row[9],
                    "location": row[10] if len(row) > 10 else "",
                    "reminder_minutes": row[11] if len(row) > 11 else 60
                }
                events.append(event)
            
            return {
                "events": events, 
                "count": len(events),
                "status": "success"
            }
            
    except Exception as e:
        logger.error(f"Error fetching events: {e}")
        return {
            "events": [], 
            "count": 0,
            "status": "error",
            "error": str(e)
        }

@app.get("/api/events/{event_id}")
async def get_single_event(event_id: int):
    """Get specific event by ID for detailed view"""
    try:
        async with aiosqlite.connect(CONFIG["database_path"]) as db:
            cursor = await db.execute("""
                SELECT id, title, description, date, time, duration, category, priority, 
                       created_at, updated_at, location, reminder_minutes
                FROM events 
                WHERE id = ?
            """, (event_id,))
            row = await cursor.fetchone()
            
            if not row:
                raise HTTPException(status_code=404, detail="Event not found")
                
            event = {
                "id": row[0],
                "title": row[1],
                "description": row[2] or "",
                "date": row[3],
                "time": row[4] or "",
                "duration": row[5] or 60,
                "category": row[6] or "personal",
                "priority": row[7] or "medium",
                "created_at": row[8],
                "updated_at": row[9],
                "location": row[10] if len(row) > 10 else "",
                "reminder_minutes": row[11] if len(row) > 11 else 60
            }
            
            return {
                "event": event,
                "status": "success"
            }
            
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error fetching event {event_id}: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/api/events")
async def create_event_via_api(event_data: dict):
    """Create new event via API for calendar form integration"""
    try:
        # Validate required fields
        if not event_data.get("title"):
            raise HTTPException(status_code=400, detail="Title is required")
        if not event_data.get("date"):
            raise HTTPException(status_code=400, detail="Date is required")
            
        async with aiosqlite.connect(CONFIG["database_path"]) as db:
            cursor = await db.execute("""
                INSERT INTO events (title, description, date, time, duration, category, priority, location, reminder_minutes)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
            """, (
                event_data.get("title"),
                event_data.get("description", ""),
                event_data.get("date"),
                event_data.get("time"),
                event_data.get("duration", 60),
                event_data.get("category", "personal"),
                event_data.get("priority", "medium"),
                event_data.get("location", ""),
                event_data.get("reminder_minutes", 60)
            ))
            
            event_id = cursor.lastrowid
            await db.commit()
            
            return {
                "event_id": event_id,
                "title": event_data.get("title"),
                "date": event_data.get("date"),
                "time": event_data.get("time"),
                "status": "created",
                "message": "Event created successfully"
            }
            
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error creating event: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/api/calendar/events")
async def get_events():
    """Get all events from database for calendar UI - returns direct list"""
    try:
        import aiosqlite
        async with aiosqlite.connect('/app/data/zoe.db') as db:
            cursor = await db.execute("""
                SELECT id, title, start_date, start_time, source, created_at
                FROM events 
                ORDER BY start_date ASC, start_time ASC
            """)
            
            events = []
            async for row in cursor:
                events.append({
                    "id": row[0],
                    "title": row[1],
                    "start_date": row[2],
                    "start_time": row[3] if row[3] else "",
                    "date": row[2],
                    "time": row[3] if row[3] else "",
                    "category": "personal",
                    "priority": "medium",
                    "description": "",
                    "location": "",
                    "source": row[4] if row[4] else "manual",
                    "created_at": row[5]
                })
            
            return events
            
    except Exception as e:
        print(f"Calendar events error: {e}")
        return []

# =============================================================================
# CALENDAR CRUD ENDPOINTS - COMPLETE FUNCTIONALITY
# =============================================================================

@app.get("/api/calendar/events/{event_id}")
async def get_calendar_event(event_id: int, user_id: str = "default"):
    """Get specific event by ID for editing"""
    try:
        async with aiosqlite.connect('/app/data/zoe.db') as db:
            cursor = await db.execute("""
                SELECT id, title, start_date, start_time, source, created_at
                FROM events 
                WHERE id = ? AND user_id = ?
            """, (event_id, user_id))
            row = await cursor.fetchone()
            
            if not row:
                raise HTTPException(status_code=404, detail="Event not found")
            
            return {
                "id": row[0],
                "title": row[1],
                "start_date": row[2],
                "start_time": row[3] or "",
                "date": row[2],
                "time": row[3] or "",
                "category": "personal",
                "priority": "medium",
                "description": "",
                "location": "",
                "source": row[4],
                "created_at": row[5]
            }
    except HTTPException:
        raise
    except Exception as e:
        print(f"Error getting event {event_id}: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.put("/api/calendar/events/{event_id}")
async def update_calendar_event(event_id: int, event_data: dict, user_id: str = "default"):
    """Update existing event"""
    try:
        async with aiosqlite.connect('/app/data/zoe.db') as db:
            # Check if event exists
            cursor = await db.execute("""
                SELECT id FROM events WHERE id = ? AND user_id = ?
            """, (event_id, user_id))
            
            if not await cursor.fetchone():
                raise HTTPException(status_code=404, detail="Event not found")
            
            # Update the event
            await db.execute("""
                UPDATE events 
                SET title = ?, start_date = ?, start_time = ?
                WHERE id = ? AND user_id = ?
            """, (
                event_data.get('title', ''),
                event_data.get('start_date') or event_data.get('date', ''),
                event_data.get('start_time') or event_data.get('time', ''),
                event_id,
                user_id
            ))
            await db.commit()
            
            return {
                "id": event_id,
                "message": "Event updated successfully",
                "updated": True
            }
    except HTTPException:
        raise
    except Exception as e:
        print(f"Error updating event {event_id}: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.delete("/api/calendar/events/{event_id}")
async def delete_calendar_event(event_id: int, user_id: str = "default"):
    """Delete event"""
    try:
        async with aiosqlite.connect('/app/data/zoe.db') as db:
            # Check if event exists
            cursor = await db.execute("""
                SELECT id, title FROM events WHERE id = ? AND user_id = ?
            """, (event_id, user_id))
            event = await cursor.fetchone()
            
            if not event:
                raise HTTPException(status_code=404, detail="Event not found")
            
            # Delete the event
            await db.execute("""
                DELETE FROM events WHERE id = ? AND user_id = ?
            """, (event_id, user_id))
            await db.commit()
            
            return {
                "id": event_id,
                "title": event[1],
                "message": "Event deleted successfully",
                "deleted": True
            }
    except HTTPException:
        raise
    except Exception as e:
        print(f"Error deleting event {event_id}: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# =============================================================================
# NOTIFICATION MANAGEMENT ENDPOINTS
# =============================================================================

@app.get("/api/notifications")
@app.get("/api/notifications")
async def get_notifications(user_id: str = "default"):
    """Get all active notifications for user"""
    try:
        async with aiosqlite.connect(CONFIG["database_path"]) as db:
            cursor = await db.execute("""
                SELECT n.id, n.event_id, n.notification_type, n.days_before, 
                       n.message, e.title, e.start_date
                FROM event_notifications n
                JOIN events e ON n.event_id = e.id
                WHERE n.user_id = ? AND n.is_active = 1
                ORDER BY e.start_date ASC
            """, (user_id,))
            rows = await cursor.fetchall()
            
            notifications = []
            for row in rows:
                notifications.append({
                    "id": row[0],
                    "event_id": row[1],
                    "notification_type": row[2],
                    "days_before": row[3],
                    "message": row[4],
                    "event_title": row[5],
                    "event_date": row[6]
                })
            
            return notifications
    except Exception as e:
        print(f"Error getting notifications: {e}")
        return []

@app.get("/api/notifications/due")
async def get_due_notifications(user_id: str = "default"):
    """Get notifications that are due now or soon"""
    try:
        from datetime import datetime, timedelta
        
        async with aiosqlite.connect(CONFIG["database_path"]) as db:
            cursor = await db.execute("""
                SELECT n.id, n.event_id, n.notification_type, n.days_before, n.hours_before, 
                       n.message, e.title, e.start_date, e.start_time
                FROM event_notifications n
                JOIN events e ON n.event_id = e.id
                WHERE n.user_id = ? AND n.is_active = 1
            """, (user_id,))
            rows = await cursor.fetchall()
            
            due_notifications = []
            now = datetime.now()
            
            for row in rows:
                try:
                    event_date = datetime.fromisoformat(row[7])  # start_date
                    
                    # Calculate when notification should fire
                    notification_time = event_date - timedelta(
                        days=row[3],  # days_before
                        hours=row[4]  # hours_before
                    )
                    
                    # Check if notification is due (within next 24 hours)
                    if notification_time <= now + timedelta(hours=24):
                        due_notifications.append({
                            "id": row[0],
                            "event_id": row[1],
                            "notification_type": row[2],
                            "message": row[5],
                            "event_title": row[6],
                            "event_date": row[7],
                            "event_time": row[8],
                            "due_date": notification_time.isoformat()
                        })
                except Exception as e:
                    print(f"Error processing notification: {e}")
                    continue
            
            return due_notifications
    except Exception as e:
        print(f"âŒ Error getting due notifications: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/api/shopping")
async def add_shopping_item(request: dict):
    """Add shopping item"""
    try:
        text = request.get("text", "").strip()
        if not text:
            return {"error": "Text required"}
        async with aiosqlite.connect("/app/data/zoe.db") as db:
            cursor = await db.execute("INSERT INTO shopping_items (list_id, text, completed) VALUES (1, ?, FALSE) RETURNING id", (text,))
            item_id = (await cursor.fetchone())[0]
            await db.commit()
            return {"id": item_id, "text": text, "completed": False, "message": f"Added '{text}'"}
    except Exception as e:
        return {"error": str(e)}

@app.put("/api/shopping/{item_id}")
async def update_shopping_item(item_id: int, request: dict):
    """Update shopping item"""
    try:
        completed = request.get("completed", False)
        async with aiosqlite.connect("/app/data/zoe.db") as db:
            await db.execute("UPDATE shopping_items SET completed = ? WHERE id = ?", (completed, item_id))
            await db.commit()
            cursor = await db.execute("SELECT text, completed FROM shopping_items WHERE id = ?", (item_id,))
            item = await cursor.fetchone()
            if item:
                return {"id": item_id, "text": item[0], "completed": bool(item[1]), "message": f"Updated '{item[0]}'"}
            else:
                return {"error": "Item not found"}
    except Exception as e:
        return {"error": str(e)}

@app.delete("/api/shopping/{item_id}")
async def delete_shopping_item(item_id: int):
    """Delete shopping item"""
    try:
        async with aiosqlite.connect("/app/data/zoe.db") as db:
            cursor = await db.execute("SELECT text FROM shopping_items WHERE id = ?", (item_id,))
            item = await cursor.fetchone()
            if item:
                await db.execute("DELETE FROM shopping_items WHERE id = ?", (item_id,))
                await db.commit()
                return {"message": f"Deleted '{item[0]}'"}
            else:
                return {"error": "Item not found"}
    except Exception as e:
        return {"error": str(e)}
